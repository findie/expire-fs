{"version":3,"sources":["../src/index.js"],"names":["fs","require","path","EventEmitter","readdirAsync","dirname","Promise","res","rej","readdir","e","l","unlinkAsync","filename","unlink","statsAsync","stat","s","rmdirAsync","rmdir","readdirSync","unlinkSync","stats","statSync","rmdirSync","ignoreENOENT","fn","args","code","undefined","validTimeTypes","ExpireFS","constructor","folder","unsafe","timeType","filter","expire","Infinity","interval","recursive","autoStart","removeEmptyDirs","removeCleanedDirs","async","Error","resolve","split","sep","length","indexOf","join","_interval","start","_readdir","_unlink","_stats","_rmdir","_shouldDelete","time","RegExp","test","Date","now","getTime","_clean","dir","list","all","map","item","deleted","isDirectory","data","then","x","file","clean","emit","stop","clearInterval","setInterval","module","exports"],"mappings":";;;;AAAA,MAAMA,KAAKC,QAAQ,IAAR,CAAX;AACA,MAAMC,OAAOD,QAAQ,MAAR,CAAb;AACA,MAAME,eAAeF,QAAQ,QAAR,CAArB;;AAEA,MAAMG,eAAeC,WAAW,IAAIC,OAAJ,CAAY,CAACC,GAAD,EAAMC,GAAN,KAAcR,GAAGS,OAAH,CAAWJ,OAAX,EAAoB,CAACK,CAAD,EAAIC,CAAJ,KAAUD,IAAIF,IAAIE,CAAJ,CAAJ,GAAaH,IAAII,CAAJ,CAA3C,CAA1B,CAAhC;AACA,MAAMC,cAAcC,YAAY,IAAIP,OAAJ,CAAY,CAACC,GAAD,EAAMC,GAAN,KAAcR,GAAGc,MAAH,CAAUD,QAAV,EAAoBH,KAAKA,IAAIF,IAAIE,CAAJ,CAAJ,GAAaH,KAAtC,CAA1B,CAAhC;AACA,MAAMQ,aAAaF,YAAY,IAAIP,OAAJ,CAAY,CAACC,GAAD,EAAMC,GAAN,KAAcR,GAAGgB,IAAH,CAAQH,QAAR,EAAkB,CAACH,CAAD,EAAIO,CAAJ,KAAUP,IAAIF,IAAIE,CAAJ,CAAJ,GAAaH,IAAIU,CAAJ,CAAzC,CAA1B,CAA/B;AACA,MAAMC,aAAaL,YAAY,IAAIP,OAAJ,CAAY,CAACC,GAAD,EAAMC,GAAN,KAAcR,GAAGmB,KAAH,CAASN,QAAT,EAAmBH,KAAKA,IAAIF,IAAIE,CAAJ,CAAJ,GAAaH,KAArC,CAA1B,CAA/B;;AAEA,MAAME,UAAUI,YAAYb,GAAGoB,WAAH,CAAeP,QAAf,CAA5B;AACA,MAAMC,SAASD,YAAYb,GAAGqB,UAAH,CAAcR,QAAd,CAA3B;AACA,MAAMS,QAAQT,YAAYb,GAAGuB,QAAH,CAAYV,QAAZ,CAA1B;AACA,MAAMM,QAAQN,YAAYb,GAAGwB,SAAH,CAAaX,QAAb,CAA1B;;AAEA,MAAMY;AAAA,+BAAe,WAAOC,EAAP,EAAW,GAAGC,IAAd,EAAuB;AAC1C,QAAI;AACF,aAAO,MAAMD,GAAG,GAAGC,IAAN,CAAb;AACD,KAFD,CAEE,OAAOjB,CAAP,EAAU;AACV,UAAIA,EAAEkB,IAAF,KAAW,QAAf,EAAyB;AACvB,eAAOC,SAAP;AACD;AACD,YAAMnB,CAAN;AACD;AACF,GATK;;AAAA;AAAA;AAAA;AAAA,IAAN;;AAWA,MAAMoB,iBAAiB,CAAC,OAAD,EAAU,OAAV,EAAmB,OAAnB,EAA4B,WAA5B,CAAvB;;AAEA,MAAMC,QAAN,SAAuB5B,YAAvB,CAAoC;;AAElC;;;;;;;;;;;;AAYA6B,cAAY;AACEC,UADF;AAEEC,aAAS,KAFX;AAGEC,eAAW,WAHb;AAIEC,aAAS,IAJX;AAKEC,aAASC,QALX;AAMEC,eAAW,IAAI,EAAJ,GAAS,IANtB;AAOEC,gBAAY,IAPd;AAQEC,gBAAY,IARd;AASEC,sBAAkB,KATpB;AAUEC,wBAAoB,IAVtB;AAWEC,YAAQ;AAXV,GAAZ,EAYe;AACb;;AAEA,QAAI,CAACX,MAAL,EAAa;AACX,YAAM,IAAIY,KAAJ,CAAU,4BAAV,CAAN;AACD;AACD,SAAKZ,MAAL,GAAc/B,KAAK4C,OAAL,CAAab,MAAb,CAAd;AACA,QAAI,CAACC,MAAD,IAAW,KAAKD,MAAL,CAAYc,KAAZ,CAAkB7C,KAAK8C,GAAvB,EAA4BC,MAA5B,IAAsC,CAArD,EAAwD;AACtD,YAAM,IAAIJ,KAAJ,CACJ,uCAAuCZ,MAAvC,GAAgD,2BAAhD,GACA,4DAFI,CAAN;AAID;;AAED,SAAKE,QAAL,GAAgBA,QAAhB;AACA,QAAI,CAAC,CAACL,eAAeoB,OAAf,CAAuB,KAAKf,QAA5B,CAAN,EAA6C;AAC3C,YAAM,IAAIU,KAAJ,CAAU,+BAA+Bf,eAAeqB,IAAf,CAAoB,IAApB,CAAzC,CAAN;AACD;;AAED,SAAKf,MAAL,GAAcA,MAAd;AACA,SAAKC,MAAL,GAAcA,MAAd;;AAEA,SAAKE,QAAL,GAAgBA,QAAhB;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACA,SAAKC,SAAL,GAAiBA,SAAjB;;AAEA,SAAKC,eAAL,GAAuBA,eAAvB;AACA,SAAKC,iBAAL,GAAyBA,iBAAzB;;AAEA,SAAKS,SAAL,GAAiB,IAAjB;;AAEA,QAAI,KAAKX,SAAT,EAAoB;AAClB,WAAKY,KAAL;AACD;;AAED,SAAKC,QAAL,GAAgB7C,OAAhB;AACA,SAAK8C,OAAL,GAAezC,MAAf;AACA,SAAK0C,MAAL,GAAclC,KAAd;AACA,SAAKmC,MAAL,GAActC,KAAd;AACA,QAAIyB,KAAJ,EAAW;AACT,WAAKU,QAAL,GAAgBlD,YAAhB;AACA,WAAKmD,OAAL,GAAe3C,WAAf;AACA,WAAK4C,MAAL,GAAczC,UAAd;AACA,WAAK0C,MAAL,GAAcvC,UAAd;AACD;AACF;;AAED;;;;;;AAMAwC,gBAAcxD,IAAd,EAAoBoB,KAApB,EAA2B;AACzB,UAAMqC,OAAOrC,MAAM,KAAKa,QAAX,CAAb;AACA;AACA,QAAI,KAAKC,MAAL,YAAuBwB,MAAvB,IAAiC,KAAKxB,MAAL,CAAYyB,IAAZ,CAAiB3D,IAAjB,MAA2B,KAAhE,EAAuE;AACrE,aAAO,KAAP;AACD;AACD;AACA,QAAI,OAAO,KAAKkC,MAAZ,KAAuB,UAAvB,IAAqC,CAAC,KAAKA,MAAL,CAAYlC,IAAZ,EAAkBoB,KAAlB,CAA1C,EAAoE;AAClE,aAAO,KAAP;AACD;AACD;AACA,QAAIwC,KAAKC,GAAL,KAAaJ,KAAKK,OAAL,EAAb,GAA8B,KAAK3B,MAAvC,EAA+C;AAC7C,aAAO,KAAP;AACD;AACD;AACA,WAAO,IAAP;AACD;;AAED;;;;;;;AAOA;;;;;;;AAOA;;;;;AAKM4B,QAAN,CAAaC,GAAb,EAAkB;AAAA;;AAAA;;AAEhB,YAAMC,OAAO,MAAM,MAAKb,QAAL,CAAcY,GAAd,CAAnB;;AAEA,aAAO,MAAM5D,QAAQ8D,GAAR,CAAYD,KACtBE,GADsB,CAClB;AAAA,eAAQnE,KAAKiD,IAAL,CAAUe,GAAV,EAAeI,IAAf,CAAR;AAAA,OADkB,EAEtBD,GAFsB;AAAA,sCAElB,WAAMnE,IAAN,EAAc;AACjB,gBAAMoB,QAAQ,MAAMG,aAAa,MAAK+B,MAAlB,EAA0BtD,IAA1B,CAApB;AACA,cAAI,CAACoB,KAAL,EAAY;AACV;AACA,mBAAO,EAAEpB,IAAF,EAAQqE,SAAS,KAAjB,EAAP;AACD;;AAED,cAAI,MAAK/B,SAAL,IAAkBlB,MAAMkD,WAAN,EAAlB,IAAyCtE,SAAS,GAAlD,IAAyDA,SAAS,IAAtE,EAA4E;AAC1E,kBAAMuE,OAAO,MAAM,MAAKR,MAAL,CAAY/D,IAAZ,EAAkBwE,IAAlB,CAAuB;AAAA,qBAAM,EAAExE,IAAF,EAAQiE,MAAMQ,CAAd,EAAiB1C,QAAQ,IAAzB,EAAN;AAAA,aAAvB,CAAnB,CAD0E,CACS;;AAEnF;AACA,gBAAI,CAAC,MAAM,MAAKqB,QAAL,CAAcpD,IAAd,CAAP,EAA4B+C,MAA5B,KAAuC,CAA3C,EAA8C;;AAE5C;AACA,kBAAI,MAAKP,eAAT,EAA0B;AACxB;AACA,sBAAM,MAAKe,MAAL,CAAYvD,IAAZ,CAAN;AACD;AACD;AAJA,mBAKK,IAAI,MAAKyC,iBAAL,IAA0B8B,KAAKN,IAAL,CAAUlB,MAAV,GAAmB,CAAjD,EAAoD;AACvD;AACA,wBAAM,MAAKQ,MAAL,CAAYvD,IAAZ,CAAN;AACD;AAEF;AACD,mBAAOuE,IAAP;AACD;;AAED,cAAI,CAACnD,MAAMkD,WAAN,EAAD,IAAwB,MAAKd,aAAL,CAAmBxD,IAAnB,EAAyBoB,KAAzB,MAAoC,IAAhE,EAAsE;AACpE,kBAAM,MAAKiC,OAAL,CAAarD,IAAb,CAAN,CADoE,CAC1C;AAC1B,mBAAO,EAAEA,IAAF,EAAQqE,SAAS,IAAjB,EAAuBK,MAAM,IAA7B,EAAP;AACD;;AAED,iBAAO,EAAE1E,IAAF,EAAQqE,SAAS,KAAjB,EAAP;AACD,SApCsB;;AAAA;AAAA;AAAA;AAAA,WAAZ,CAAb;AAJgB;AA0CjB;;AAED;;;AAGMM,OAAN,GAAc;AAAA;;AAAA;AACZ,YAAMJ,OAAO,MAAM,OAAKR,MAAL,CAAY,OAAKhC,MAAjB,CAAnB;AACA,aAAK6C,IAAL,CAAU,OAAV,EAAmBL,IAAnB;AACA,aAAOA,IAAP;AAHY;AAIb;;AAED;;;AAGAM,SAAO;AACL,QAAI,CAAC,KAAK3B,SAAV,EAAqB;AACnB,aAAO,KAAP,CADmB,CACL;AACf;AACD4B,kBAAc,KAAK5B,SAAnB;AACA,SAAKA,SAAL,GAAiB,IAAjB;AACA,WAAO,IAAP;AACD;;AAED;;;AAGAC,UAAQ;AAAA;;AACN,QAAI,KAAKD,SAAT,EAAoB;AAClB,aAAO,KAAP,CADkB,CACJ;AACf;AACD,SAAKA,SAAL,GAAiB6B,8BAAY,aAAY;AACvC,UAAI;AACF,cAAM,OAAKJ,KAAL,EAAN;AACD,OAFD,CAEE,OAAOnE,CAAP,EAAU;AACV,eAAKoE,IAAL,CAAU,OAAV,EAAmBpE,CAAnB;AACD;AACF,KANgB,GAMd,KAAK6B,QANS,CAAjB;AAOA,WAAO,IAAP;AACD;AApMiC;;AAuMpC2C,OAAOC,OAAP,GAAiBpD,QAAjB","file":"index.js","sourcesContent":["const fs = require('fs');\nconst path = require('path');\nconst EventEmitter = require('events');\n\nconst readdirAsync = dirname => new Promise((res, rej) => fs.readdir(dirname, (e, l) => e ? rej(e) : res(l)));\nconst unlinkAsync = filename => new Promise((res, rej) => fs.unlink(filename, e => e ? rej(e) : res()));\nconst statsAsync = filename => new Promise((res, rej) => fs.stat(filename, (e, s) => e ? rej(e) : res(s)));\nconst rmdirAsync = filename => new Promise((res, rej) => fs.rmdir(filename, e => e ? rej(e) : res()));\n\nconst readdir = filename => fs.readdirSync(filename);\nconst unlink = filename => fs.unlinkSync(filename);\nconst stats = filename => fs.statSync(filename);\nconst rmdir = filename => fs.rmdirSync(filename);\n\nconst ignoreENOENT = async (fn, ...args) => {\n  try {\n    return await fn(...args);\n  } catch (e) {\n    if (e.code === 'ENOENT') {\n      return undefined;\n    }\n    throw e;\n  }\n};\n\nconst validTimeTypes = ['atime', 'mtime', 'ctime', 'birthtime'];\n\nclass ExpireFS extends EventEmitter {\n\n  /**\n   * @param options\n   * @param {String} options.folder\n   * @param {RegExp|function(String,Stats):Boolean=} options.filter\n   * @param {String=} [options.timeType='birthtime']\n   * @param {Number=} [options.expire=Infinity] - milliseconds\n   * @param {Number=} [options.interval=300000] - milliseconds\n   * @param {Boolean=} [options.recursive=true]\n   * @param {Boolean=} [options.autoStart=true]\n   * @param {Boolean=} [options.unsafe=false]\n   * @param {Boolean=} [options.removeEmptyDirs=false]\n   */\n  constructor({\n                folder,\n                unsafe = false,\n                timeType = 'birthtime',\n                filter = /.*/,\n                expire = Infinity,\n                interval = 5 * 60 * 1000,\n                recursive = true,\n                autoStart = true,\n                removeEmptyDirs = false,\n                removeCleanedDirs = true,\n                async = true\n              }) {\n    super();\n\n    if (!folder) {\n      throw new Error('folder should be specified');\n    }\n    this.folder = path.resolve(folder);\n    if (!unsafe && this.folder.split(path.sep).length <= 2) {\n      throw new Error(\n        'Cowardly refusing to watch folder ' + folder + ' as it is a root folder. ' +\n        'To override this behaviour, please set \"unsafe\" to be true'\n      );\n    }\n\n    this.timeType = timeType;\n    if (!~validTimeTypes.indexOf(this.timeType)) {\n      throw new Error('timeType should be one of ' + validTimeTypes.join(', '));\n    }\n\n    this.filter = filter;\n    this.expire = expire;\n\n    this.interval = interval;\n    this.recursive = recursive;\n    this.autoStart = autoStart;\n\n    this.removeEmptyDirs = removeEmptyDirs;\n    this.removeCleanedDirs = removeCleanedDirs;\n\n    this._interval = null;\n\n    if (this.autoStart) {\n      this.start();\n    }\n\n    this._readdir = readdir;\n    this._unlink = unlink;\n    this._stats = stats;\n    this._rmdir = rmdir;\n    if (async) {\n      this._readdir = readdirAsync;\n      this._unlink = unlinkAsync;\n      this._stats = statsAsync;\n      this._rmdir = rmdirAsync;\n    }\n  }\n\n  /**\n   * @param {String} path\n   * @param {Stats} stats\n   * @return {boolean}\n   * @private\n   */\n  _shouldDelete(path, stats) {\n    const time = stats[this.timeType];\n    // if regex check match (false)\n    if (this.filter instanceof RegExp && this.filter.test(path) === false) {\n      return false;\n    }\n    // if function check output (falsy)\n    if (typeof this.filter === 'function' && !this.filter(path, stats)) {\n      return false;\n    }\n    // if now - chosen time < expire time\n    if (Date.now() - time.getTime() < this.expire) {\n      return false;\n    }\n    // delete it\n    return true;\n  }\n\n  /**\n   * @typedef {Object} ExpireFSFolderFile\n   * @property {String} path\n   * @property {Boolean} deleted\n   * @property {Boolean} file\n   */\n\n  /**\n   * @typedef {Object} ExpireFSFolderChain\n   * @property {String} path\n   * @property {Boolean} folder\n   * @property {Array.<ExpireFSFolderFile|ExpireFSFolderChain>}} list\n   */\n\n  /**\n   * @param {String} dir\n   * @return {PromiseLike<ExpireFSFolderChain[]> | Promise<ExpireFSFolderChain[]>}\n   * @private\n   */\n  async _clean(dir) {\n\n    const list = await this._readdir(dir);\n\n    return await Promise.all(list\n      .map(item => path.join(dir, item))\n      .map(async path => {\n        const stats = await ignoreENOENT(this._stats, path);\n        if (!stats) {\n          // it's been already deleted\n          return { path, deleted: false }\n        }\n\n        if (this.recursive && stats.isDirectory() && path !== '.' && path !== '..') {\n          const data = await this._clean(path).then(x => ({ path, list: x, folder: true })); // recursive on next dir\n\n          // if dir is empty\n          if ((await this._readdir(path)).length === 0) {\n\n            // and if we want to delete empty dirs\n            if (this.removeEmptyDirs) {\n              // delete dir\n              await this._rmdir(path);\n            }\n            // and if we want to delete only dirs that have been cleaned up\n            else if (this.removeCleanedDirs && data.list.length > 0) {\n              // delete dir\n              await this._rmdir(path);\n            }\n\n          }\n          return data;\n        }\n\n        if (!stats.isDirectory() && this._shouldDelete(path, stats) === true) {\n          await this._unlink(path); // delete file\n          return { path, deleted: true, file: true };\n        }\n\n        return { path, deleted: false }\n      })\n    );\n  }\n\n  /**\n   * @return {PromiseLike<ExpireFSFolderChain[]> | Promise<ExpireFSFolderChain[]>}\n   */\n  async clean() {\n    const data = await this._clean(this.folder);\n    this.emit('clean', data);\n    return data;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  stop() {\n    if (!this._interval) {\n      return false; // not started\n    }\n    clearInterval(this._interval);\n    this._interval = null;\n    return true;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  start() {\n    if (this._interval) {\n      return false; // already started\n    }\n    this._interval = setInterval(async () => {\n      try {\n        await this.clean();\n      } catch (e) {\n        this.emit('error', e);\n      }\n    }, this.interval);\n    return true;\n  }\n}\n\nmodule.exports = ExpireFS;\n"]}