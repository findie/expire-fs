{"version":3,"sources":["../src/index.js"],"names":["fs","require","path","EventEmitter","diskusage","debug","debug_expire","debug_pressure","debug_entry","readdirAsync","dirname","Promise","res","rej","readdir","e","l","unlinkAsync","filename","unlink","statsAsync","stat","s","rmdirAsync","rmdir","readdirSync","unlinkSync","stats","statSync","rmdirSync","pretty_size","size","names","i","length","toFixed","validTimeTypes","Set","ExpireEntry","constructor","async","parent","_path","_async","_stats","_parent","_children","Map","_get_list","_get_stats","_rm_dir","_rm_file","basename","isDir","isDirectory","isRoot","getTime","type","children","childrenList","keys","hasChildren","childrenValues","values","populate","console","warn","message","list","len","entries","name","entry","join","push","set","all","map","delete","keepEmptyParent","dry","removeRoot","child","log","traverse","callback","c","traverseAsync","ExpireFS","folder","unsafe","timeType","filter","expire","Infinity","pressure","interval","autoStart","removeEmptyDirs","removeCleanedDirs","Error","resolve","split","sep","has","_interval","start","_shouldDelete","time","RegExp","test","Date","now","_expire","deleted","_pressure","disk","check","checkSync","usagePerc","available","total","shouldBe","toFree","sort","a","b","item","pop","clean","emit","stop","clearInterval","setInterval","TimeType","access_time","modify_time","creation_time","birth_time","module","exports"],"mappings":";;;;AAAA,MAAMA,KAAKC,QAAQ,IAAR,CAAX;AACA,MAAMC,OAAOD,QAAQ,MAAR,CAAb;AACA,MAAME,eAAeF,QAAQ,QAAR,CAArB;AACA,MAAMG,YAAYH,QAAQ,WAAR,CAAlB;AACA,MAAMI,QAAQJ,QAAQ,OAAR,CAAd;;AAEA,MAAMK,eAAeD,MAAM,kBAAN,CAArB;AACA,MAAME,iBAAiBF,MAAM,oBAAN,CAAvB;AACA,MAAMG,cAAcH,MAAM,iBAAN,CAApB;;AAEA,MAAMI,eAAeC,WAAW,IAAIC,OAAJ,CAAY,CAACC,GAAD,EAAMC,GAAN,KAAcb,GAAGc,OAAH,CAAWJ,OAAX,EAAoB,CAACK,CAAD,EAAIC,CAAJ,KAAUD,IAAIF,IAAIE,CAAJ,CAAJ,GAAaH,IAAII,CAAJ,CAA3C,CAA1B,CAAhC;AACA,MAAMC,cAAcC,YAAY,IAAIP,OAAJ,CAAY,CAACC,GAAD,EAAMC,GAAN,KAAcb,GAAGmB,MAAH,CAAUD,QAAV,EAAoBH,KAAKA,IAAIF,IAAIE,CAAJ,CAAJ,GAAaH,KAAtC,CAA1B,CAAhC;AACA,MAAMQ,aAAaF,YAAY,IAAIP,OAAJ,CAAY,CAACC,GAAD,EAAMC,GAAN,KAAcb,GAAGqB,IAAH,CAAQH,QAAR,EAAkB,CAACH,CAAD,EAAIO,CAAJ,KAAUP,IAAIF,IAAIE,CAAJ,CAAJ,GAAaH,IAAIU,CAAJ,CAAzC,CAA1B,CAA/B;AACA,MAAMC,aAAaL,YAAY,IAAIP,OAAJ,CAAY,CAACC,GAAD,EAAMC,GAAN,KAAcb,GAAGwB,KAAH,CAASN,QAAT,EAAmBH,KAAKA,IAAIF,IAAIE,CAAJ,CAAJ,GAAaH,KAArC,CAA1B,CAA/B;;AAEA,MAAME,UAAUI,YAAYlB,GAAGyB,WAAH,CAAeP,QAAf,CAA5B;AACA,MAAMC,SAASD,YAAYlB,GAAG0B,UAAH,CAAcR,QAAd,CAA3B;AACA,MAAMS,QAAQT,YAAYlB,GAAG4B,QAAH,CAAYV,QAAZ,CAA1B;AACA,MAAMM,QAAQN,YAAYlB,GAAG6B,SAAH,CAAaX,QAAb,CAA1B;;AAEA,MAAMY,cAAeC,IAAD,IAAU;AAC5B,QAAMC,QAAQ,CAAC,GAAD,EAAM,IAAN,EAAY,IAAZ,EAAkB,IAAlB,CAAd;AACA,MAAIC,IAAI,CAAR;AACA,SAAOF,OAAO,IAAP,IAAeE,IAAID,MAAME,MAAN,GAAe,CAAzC,EAA4C;AAC1CD;AACAF,YAAQ,IAAR;AACD;;AAED,SAAQ,GAAEA,KAAKI,OAAL,CAAa,CAAb,CAAgB,GAAEH,MAAMC,CAAN,CAAS,EAArC;AACD,CATD;;AAWA,MAAMG,iBAAiB,IAAIC,GAAJ,CAAQ,CAAC,OAAD,EAAU,OAAV,EAAmB,OAAnB,EAA4B,WAA5B,CAAR,CAAvB;;AAEA,MAAMC,WAAN,CAAkB;AAChB;;;;;AAKAC,cAAY,EAAEC,QAAQ,KAAV,EAAiBtC,IAAjB,EAAuBuC,MAAvB,EAAZ,EAA6C;AAC3C,SAAKC,KAAL,GAAaxC,IAAb;AACA,SAAKyC,MAAL,GAAcH,KAAd;AACA;;;;AAIA,SAAKI,MAAL,GAAc,IAAd;;AAEA,SAAKC,OAAL,GAAeJ,MAAf;AACA;;;;AAIA,SAAKK,SAAL,GAAiB,IAAIC,GAAJ,EAAjB;;AAEA;AACA,SAAKC,SAAL,GAAiBR,QAAQ/B,YAAR,GAAuBK,OAAxC;AACA;AACA,SAAKmC,UAAL,GAAkBT,QAAQpB,UAAR,GAAqBO,KAAvC;AACA;AACA,SAAKuB,OAAL,GAAeV,QAAQjB,UAAR,GAAqBC,KAApC;AACA;AACA,SAAK2B,QAAL,GAAgBX,QAAQvB,WAAR,GAAsBE,MAAtC;AACD;;AAED;;;AAGA,MAAIjB,IAAJ,GAAW;AACT,WAAO,KAAKwC,KAAZ;AACD;;AAED;;;AAGA,MAAIU,QAAJ,GAAe;AACb,WAAOlD,KAAKkD,QAAL,CAAc,KAAKV,KAAnB,CAAP;AACD;;AAED;;;AAGA,MAAIW,KAAJ,GAAY;AACV,WAAO,KAAKT,MAAL,CAAYU,WAAZ,EAAP;AACD;;AAED;;;AAGA,MAAIC,MAAJ,GAAa;AACX,WAAO,CAAC,KAAKV,OAAb;AACD;;AAED;;;;AAIAW,UAAQC,IAAR,EAAc;AACZ,WAAO,KAAKb,MAAL,CAAYa,IAAZ,CAAP;AACD;;AAED;;;AAGA,MAAI1B,IAAJ,GAAW;AACT,WAAO,KAAKa,MAAL,CAAYb,IAAnB;AACD;;AAED;;;AAGA,MAAIJ,KAAJ,GAAY;AACV,WAAO,KAAKiB,MAAZ;AACD;;AAED;;;AAGA,MAAIH,MAAJ,GAAa;AACX,WAAO,KAAKI,OAAZ;AACD;;AAED;;;AAGA,MAAIa,QAAJ,GAAe;AACb,WAAO,KAAKZ,SAAZ;AACD;;AAED;;;AAGA,MAAIa,YAAJ,GAAmB;AACjB,WAAO,CAAC,GAAG,KAAKb,SAAL,CAAec,IAAf,EAAJ,CAAP;AACD;;AAED,MAAIC,WAAJ,GAAkB;AAChB,WAAO,KAAKf,SAAL,CAAef,IAAf,KAAwB,CAA/B;AACD;;AAED;;;AAGA,MAAI+B,cAAJ,GAAqB;AACnB,WAAO,CAAC,GAAG,KAAKhB,SAAL,CAAeiB,MAAf,EAAJ,CAAP;AACD;;AAED;;;AAGMC,UAAN,GAAiB;AAAA;;AAAA;AACf,UAAI;AACF,cAAKpB,MAAL,GAAc,MAAM,MAAKK,UAAL,CAAgB,MAAKP,KAArB,CAApB;AACD,OAFD,CAEE,OAAO3B,CAAP,EAAU;AACVkD,gBAAQC,IAAR,CAAc,2BAA0B,MAAKxB,KAAM,KAAI3B,EAAEoD,OAAF,IAAapD,CAAE,EAAtE;AACA;AACD;;AAED,UAAI,CAAC,MAAKsC,KAAV,EAAiB;AACf;AACD;;AAED,UAAIe,OAAO,EAAX;AACA,UAAI;AACFA,eAAO,MAAM,MAAKpB,SAAL,CAAe,MAAKN,KAApB,CAAb;AACD,OAFD,CAEE,OAAO3B,CAAP,EAAU;AACVkD,gBAAQC,IAAR,CAAc,iCAAgC,MAAKxB,KAAM,KAAI3B,EAAEoD,OAAF,IAAapD,CAAE,EAA5E;AACA;AACD;;AAED,YAAMsD,MAAMD,KAAKlC,MAAjB;;AAEA,YAAMoC,UAAU,EAAhB;AACA,WAAK,IAAIrC,IAAI,CAAb,EAAgBA,IAAIoC,GAApB,EAAyBpC,GAAzB,EAA8B;AAC5B,cAAMsC,OAAOH,KAAKnC,CAAL,CAAb;AACA,YAAIsC,SAAS,IAAT,IAAiBA,SAAS,GAA9B,EAAmC;AACjC;AACD;;AAED,cAAMC,QAAQ,IAAIlC,WAAJ,CAAgB;AAC5BE,iBAAO,MAAKG,MADgB;AAE5BzC,gBAAMA,KAAKuE,IAAL,CAAU,MAAKvE,IAAf,EAAqBqE,IAArB,CAFsB;AAG5B9B,kBAAQ;AAHoB,SAAhB,CAAd;AAKA6B,gBAAQI,IAAR,CAAaF,KAAb;AACA,cAAKd,QAAL,CAAciB,GAAd,CAAkBH,MAAMpB,QAAxB,EAAkCoB,KAAlC;AACD;;AAED,YAAM7D,QAAQiE,GAAR,CAAYN,QAAQO,GAAR,CAAY;AAAA,eAAK9D,EAAEiD,QAAF,EAAL;AAAA,OAAZ,CAAZ,CAAN;AAtCe;AAuChB;;AAED;;;;;;AAMMc,QAAN,CAAa,EAAEC,kBAAkB,IAApB,EAA0BC,MAAM,KAAhC,EAAuCC,aAAa,KAApD,KAA8D,EAA3E,EAA+E;AAAA;;AAAA;AAC7EzE,kBAAY,gBAAZ,EAA8B,OAAKN,IAAnC;;AAEA,UAAI,OAAKmD,KAAT,EAAgB;AACd,cAAM1C,QAAQiE,GAAR,CACJ,OAAKd,cAAL,CAAoBe,GAApB,CAAwB;AAAA,iBAASK,MAAMJ,MAAN,CAAa;AAC5CC,6BAAiB,IAD2B;AAE5CC;AAF4C,WAAb,CAAT;AAAA,SAAxB,CADI,CAAN;;AAMA;AACA,YACE,CAACD,eAAD,KAEE,CAAC,OAAKxB,MAAN,IACC,OAAKA,MAAL,IAAe0B,UAHlB,CADF,EAME;;AAEA,cAAI;AACF,kBACED,MACEf,QAAQkB,GAAR,CAAY,WAAZ,EAAyB,OAAKzC,KAA9B,CADF,GAEE,OAAKQ,OAAL,CAAa,OAAKR,KAAlB,CAHJ;AAKD,WAND,CAME,OAAO3B,CAAP,EAAU;AACVkD,oBAAQC,IAAR,CAAc,sBAAqB,OAAKxB,KAAM,KAAI3B,EAAEoD,OAAF,IAAapD,CAAE,EAAjE;AACA;AACD;AACF;AACF,OA3BD,MA2BO;AACL,YAAI;AACF,gBACEiE,MACEf,QAAQkB,GAAR,CAAY,WAAZ,EAAyB,OAAKjF,IAA9B,CADF,GAEE,OAAKiD,QAAL,CAAc,OAAKT,KAAnB,CAHJ;AAKD,SAND,CAME,OAAO3B,CAAP,EAAU;AACVkD,kBAAQC,IAAR,CAAc,uBAAsB,OAAKxB,KAAM,KAAI3B,EAAEoD,OAAF,IAAapD,CAAE,EAAlE;AACA;AACD;AACF;;AAED,UAAI,OAAK0B,MAAT,EAAiB;AACf,eAAKA,MAAL,CAAYiB,QAAZ,CAAqBoB,MAArB,CAA4B,OAAK1B,QAAjC;;AAEA,YAAI,CAAC2B,eAAD,IAAoB,OAAKtC,MAAL,CAAYiB,QAAZ,CAAqB3B,IAArB,KAA8B,CAAtD,EAAyD;AACvD,gBAAM,OAAKU,MAAL,CAAYqC,MAAZ,CAAmB,EAAEC,eAAF,EAAmBC,GAAnB,EAAnB,CAAN;AACD;AACF;AAjD4E;AAkD9E;;AAED;;;AAGAI,WAASC,QAAT,EAAmB;AACjB,UAAM3B,WAAW,KAAKI,cAAtB;AACA,UAAMO,MAAMX,SAASxB,MAArB;;AAEA,SAAK,IAAID,IAAI,CAAb,EAAgBA,IAAIoC,GAApB,EAAyBpC,GAAzB,EAA8B;AAC5B,YAAMqD,IAAI5B,SAASzB,CAAT,CAAV;AACAoD,eAASC,CAAT;;AAEA,UAAIA,EAAEjC,KAAN,EAAa;AACXiC,UAAEF,QAAF,CAAWC,QAAX;AACD;AACF;AACF;;AAED;;;;AAIME,eAAN,CAAoBF,QAApB,EAA8B;AAAA;;AAAA;AAC5B,YAAM3B,WAAW,OAAKI,cAAtB;AACA,YAAMO,MAAMX,SAASxB,MAArB;;AAEA,WAAK,IAAID,IAAI,CAAb,EAAgBA,IAAIoC,GAApB,EAAyBpC,GAAzB,EAA8B;AAC5B,cAAMqD,IAAI5B,SAASzB,CAAT,CAAV;AACA,cAAMoD,SAASC,CAAT,CAAN;;AAEA,YAAIA,EAAEjC,KAAN,EAAa;AACX,gBAAMiC,EAAEC,aAAF,CAAgBF,QAAhB,CAAN;AACD;AACF;AAX2B;AAY7B;;AAED;;;AAGAjB,SAAO;AACL,UAAMA,OAAO,EAAb;;AAEA,SAAKgB,QAAL,CAAerE,CAAD,IAAO;AACnBqD,WAAKM,IAAL,CAAU3D,CAAV;AACD,KAFD;;AAIA,WAAOqD,IAAP;AACD;AAtQe;;AA0QlB,MAAMoB,QAAN,SAAuBrF,YAAvB,CAAoC;;AAElC;;;;;;;;;;;;;;;AAeAoC,cAAY;AACEkD,UADF;AAEEC,aAAS,KAFX;AAGEC,eAAW,WAHb;AAIEC,aAAS,IAJX;AAKEC,aAASC,QALX;AAMEC,eAAW,CANb;AAOEC,eAAW,IAAI,EAAJ,GAAS,IAPtB;AAQEC,gBAAY,IARd;AASEC,sBAAkB,KATpB;AAUEC,wBAAoB,IAVtB;AAWElB,iBAAa,KAXf;AAYEzC,YAAQ,IAZV;AAaEwC,UAAM;AAbR,GAAZ,EAce;AACb;;AAEA,QAAI,CAACS,MAAL,EAAa;AACX,YAAM,IAAIW,KAAJ,CAAU,4BAAV,CAAN;AACD;AACD,SAAKX,MAAL,GAAcvF,KAAKmG,OAAL,CAAaZ,MAAb,CAAd;AACA,QAAI,CAACC,MAAD,IAAW,KAAKD,MAAL,CAAYa,KAAZ,CAAkBpG,KAAKqG,GAAvB,EAA4BrE,MAA5B,IAAsC,CAArD,EAAwD;AACtD,YAAM,IAAIkE,KAAJ,CACJ,uCAAuCX,MAAvC,GAAgD,2BAAhD,GACA,4DAFI,CAAN;AAID;;AAED,SAAKE,QAAL,GAAgBA,QAAhB;AACA,QAAI,CAACvD,eAAeoE,GAAf,CAAmB,KAAKb,QAAxB,CAAL,EAAwC;AACtC,YAAM,IAAIS,KAAJ,CAAU,+BAA+B,CAAC,GAAGhE,cAAJ,EAAoBqC,IAApB,CAAyB,IAAzB,CAAzC,CAAN;AACD;;AAED,SAAKmB,MAAL,GAAcA,MAAd;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKE,QAAL,GAAgBA,QAAhB;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACA,SAAK3F,YAAL,GAAoBA,YAApB;AACA,SAAKC,cAAL,GAAsBA,cAAtB;;AAEA,SAAK2F,eAAL,GAAuBA,eAAvB;AACA,SAAKC,iBAAL,GAAyBA,iBAAzB;AACA,SAAKlB,UAAL,GAAkBA,UAAlB;;AAEA,SAAKD,GAAL,GAAWA,GAAX;;AAEA,SAAKyB,SAAL,GAAiB,IAAjB;;AAEA,QAAI,KAAKR,SAAT,EAAoB;AAClB,WAAKS,KAAL;AACD;;AAED,SAAK/D,MAAL,GAAcH,KAAd;AACD;;AAED;;;AAGM4B,MAAN,GAAa;AAAA;;AAAA;AACX,YAAMI,QAAQ,IAAIlC,WAAJ,CAAgB;AAC5BE,eAAO,OAAKG,MADgB;AAE5BzC,cAAM,OAAKuF,MAFiB;AAG5BhD,gBAAQ;AAHoB,OAAhB,CAAd;AAKA,YAAM+B,MAAMR,QAAN,EAAN;AACA,aAAOQ,KAAP;AAPW;AAQZ;;AAED;;;;;;AAMAmC,gBAAczG,IAAd,EAAoByB,KAApB,EAA2B;AACzB,UAAMiF,OAAOjF,MAAM,KAAKgE,QAAX,CAAb;AACA;AACA,QAAI,KAAKC,MAAL,YAAuBiB,MAAvB,IAAiC,KAAKjB,MAAL,CAAYkB,IAAZ,CAAiB5G,IAAjB,MAA2B,KAAhE,EAAuE;AACrE,aAAO,KAAP;AACD;AACD;AACA,QAAI,OAAO,KAAK0F,MAAZ,KAAuB,UAAvB,IAAqC,CAAC,KAAKA,MAAL,CAAY1F,IAAZ,EAAkByB,KAAlB,CAA1C,EAAoE;AAClE,aAAO,KAAP;AACD;AACD;AACA,QAAIoF,KAAKC,GAAL,KAAaJ,KAAKpD,OAAL,EAAb,GAA8B,KAAKqC,MAAvC,EAA+C;AAC7C,aAAO,KAAP;AACD;AACD;AACA,WAAO,IAAP;AACD;;AAED;;;;;;AAMMoB,SAAN,CAAc,EAAEzC,KAAF,EAASQ,GAAT,EAAd,EAA8B;AAAA;;AAAA;AAC5B,YAAMZ,OAAOI,MAAMJ,IAAN,EAAb;AACA,YAAMC,MAAMD,KAAKlC,MAAjB;AACA,YAAMgF,UAAU,EAAhB;;AAEA,WAAK,IAAIjF,IAAI,CAAb,EAAgBA,IAAIoC,GAApB,EAAyBpC,GAAzB,EAA8B;AAC5B,cAAMlB,IAAIqD,KAAKnC,CAAL,CAAV;;AAEA;AACA,YAAI,OAAKiE,eAAL,IAAwBnF,EAAEsC,KAA1B,IAAmC,CAACtC,EAAE8C,WAA1C,EAAuD;AACrD,iBAAKvD,YAAL,CAAkB,oBAAlB,EAAwCS,EAAEb,IAA1C;AACA,gBAAMa,EAAE+D,MAAF,CAAS;AACbC,6BAAiB,CAAC,OAAKoB,iBADV;AAEbnB,eAFa;AAGbC,wBAAY,OAAKA;AAHJ,WAAT,CAAN;AAKAiC,kBAAQxC,IAAR,CAAa3D,CAAb;AACD;;AAED;AACA,YAAIA,EAAEsC,KAAN,EAAa;AACX,iBAAK/C,YAAL,CAAkB,cAAlB,EAAkCS,EAAEb,IAApC;AACA;AACD;;AAED;AACA,YAAI,OAAKyG,aAAL,CAAmB5F,EAAEb,IAArB,EAA2Ba,EAAEY,KAA7B,CAAJ,EAAyC;AACvC,iBAAKrB,YAAL,CAAkB,eAAlB,EAAmCS,EAAEb,IAArC;AACA,gBAAMa,EAAE+D,MAAF,CAAS;AACbC,6BAAiB,CAAC,OAAKoB,iBADV;AAEbnB,eAFa;AAGbC,wBAAY,OAAKA;AAHJ,WAAT,CAAN;AAKAiC,kBAAQxC,IAAR,CAAa3D,CAAb;AACD,SARD,MAQO;AACL,iBAAKT,YAAL,CAAkB,cAAlB,EAAkCS,EAAEb,IAApC;AACD;AACF;AACD,aAAOgH,OAAP;AAtC4B;AAuC7B;;AAED;;;;;;AAMMC,WAAN,CAAgB,EAAE3C,KAAF,EAASQ,GAAT,EAAhB,EAAgC;AAAA;;AAAA;AAC9B,YAAMkC,UAAU,EAAhB;;AAEA,YAAM9C,OAAOI,MAAMJ,IAAN,EAAb;AACA,YAAMgD,OAAO,MACX,OAAKzE,MAAL,GACEvC,UAAUiH,KAAV,CAAgB7C,MAAMtE,IAAtB,CADF,GAEEE,UAAUkH,SAAV,CAAoB9C,MAAMtE,IAA1B,CAHJ;;AAMA,YAAMqH,YAAY,IAAKH,KAAKI,SAAL,GAAiBJ,KAAKK,KAA7C;;AAEA,UAAIF,YAAY,OAAKxB,QAArB,EAA+B;AAC7B,eAAO,EAAP;AACD;;AAED,YAAM2B,WAAWN,KAAKK,KAAL,GAAa,OAAK1B,QAAnC;AACA,UAAI4B,SAAUP,KAAKK,KAAL,GAAaL,KAAKI,SAAnB,GAAgCE,QAA7C;;AAEAnH,qBAAgB,iBAAgB,CAACgH,YAAY,GAAb,EAAkBpF,OAAlB,CAA0B,CAA1B,CAA6B,GAA7D;AACA5B,qBAAgB,gBAAeuB,YAAY6F,MAAZ,CAAoB,EAAnD;;AAEA;AACAvD,WAAKwD,IAAL,CAAU,UAACC,CAAD,EAAIC,CAAJ;AAAA,eAAUA,EAAEtE,OAAF,CAAU,OAAKmC,QAAf,IAA2BkC,EAAErE,OAAF,CAAU,OAAKmC,QAAf,CAArC;AAAA,OAAV;;AAEA,aAAOvB,KAAKlC,MAAL,IAAeyF,SAAS,CAA/B,EAAkC;AAChC,cAAMI,OAAO3D,KAAK4D,GAAL,EAAb;AACA,YAAID,KAAK1E,KAAT,EAAgB;AACd;AACD;;AAEDsE,kBAAUI,KAAKhG,IAAf;AACA,cAAMgG,KAAKjD,MAAL,CAAY,EAAEE,GAAF,EAAOD,iBAAiB,CAAC,OAAKoB,iBAA9B,EAAZ,CAAN;AACAe,gBAAQxC,IAAR,CAAaqD,IAAb;AACAxH,uBAAgB,SAAQuB,YAAYiG,KAAKhG,IAAjB,CAAuB,WAAUD,YAAY6F,MAAZ,CAAoB,EAA7E;AACD;AACD,aAAOT,OAAP;AApC8B;AAqC/B;;AAED;;;;AAIMe,OAAN,CAAY,EAAEjD,MAAM,KAAKA,GAAb,KAAqB,EAAjC,EAAqC;AAAA;;AAAA;AACnC,YAAMR,QAAQ,MAAM,OAAKJ,IAAL,EAApB;AACA,YAAM8C,UAAU,EAAhB;AACAA,cAAQxC,IAAR,CAAa,IAAG,MAAM,OAAKuC,OAAL,CAAa,EAAEjC,GAAF,EAAOR,KAAP,EAAb,CAAT,CAAb;AACA0C,cAAQxC,IAAR,CAAa,IAAG,MAAM,OAAKyC,SAAL,CAAe,EAAEnC,GAAF,EAAOR,KAAP,EAAf,CAAT,CAAb;AACA,aAAK0D,IAAL,CAAU,OAAV,EAAmBhB,OAAnB;AACA,aAAOA,OAAP;AANmC;AAOpC;;AAED;;;AAGAiB,SAAO;AACL,QAAI,CAAC,KAAK1B,SAAV,EAAqB;AACnB,aAAO,KAAP,CADmB,CACL;AACf;AACD2B,kBAAc,KAAK3B,SAAnB;AACA,SAAKA,SAAL,GAAiB,IAAjB;AACA,WAAO,IAAP;AACD;;AAED;;;AAGAC,UAAQ;AAAA;;AACN,QAAI,KAAKD,SAAT,EAAoB;AAClB,aAAO,KAAP,CADkB,CACJ;AACf;AACD,SAAKA,SAAL,GAAiB4B,8BAAY,aAAY;AACvC,UAAI;AACF,cAAM,OAAKJ,KAAL,EAAN;AACD,OAFD,CAEE,OAAOlH,CAAP,EAAU;AACV,eAAKmH,IAAL,CAAU,OAAV,EAAmBnH,CAAnB;AACD;AACF,KANgB,GAMd,KAAKiF,QANS,CAAjB;AAOA,WAAO,IAAP;AACD;AAlPiC;;AAqPpC;;;;AAIAR,SAAS8C,QAAT,GAAoB;AAClBC,eAAa,OADK;AAElBC,eAAa,OAFK;AAGlBC,iBAAe,OAHG;AAIlBC,cAAY;AAJM,CAApB;;AAOAC,OAAOC,OAAP,GAAiBpD,QAAjB","file":"index.js","sourcesContent":["const fs = require('fs');\nconst path = require('path');\nconst EventEmitter = require('events');\nconst diskusage = require('diskusage');\nconst debug = require('debug');\n\nconst debug_expire = debug('expire-fs:expire');\nconst debug_pressure = debug('expire-fs:pressure');\nconst debug_entry = debug('expire-fs:entry');\n\nconst readdirAsync = dirname => new Promise((res, rej) => fs.readdir(dirname, (e, l) => e ? rej(e) : res(l)));\nconst unlinkAsync = filename => new Promise((res, rej) => fs.unlink(filename, e => e ? rej(e) : res()));\nconst statsAsync = filename => new Promise((res, rej) => fs.stat(filename, (e, s) => e ? rej(e) : res(s)));\nconst rmdirAsync = filename => new Promise((res, rej) => fs.rmdir(filename, e => e ? rej(e) : res()));\n\nconst readdir = filename => fs.readdirSync(filename);\nconst unlink = filename => fs.unlinkSync(filename);\nconst stats = filename => fs.statSync(filename);\nconst rmdir = filename => fs.rmdirSync(filename);\n\nconst pretty_size = (size) => {\n  const names = ['B', 'KB', 'MB', 'GB'];\n  let i = 0;\n  while (size > 1024 && i < names.length - 1) {\n    i++;\n    size /= 1024;\n  }\n\n  return `${size.toFixed(2)}${names[i]}`;\n};\n\nconst validTimeTypes = new Set(['atime', 'mtime', 'ctime', 'birthtime']);\n\nclass ExpireEntry {\n  /**\n   * @param {boolean} async\n   * @param {string} path\n   * @param {ExpireEntry|null} parent\n   */\n  constructor({ async = false, path, parent }) {\n    this._path = path;\n    this._async = async;\n    /**\n     * @type {Stats}\n     * @private\n     */\n    this._stats = null;\n\n    this._parent = parent;\n    /**\n     * @type {Map<string, ExpireEntry>}\n     * @private\n     */\n    this._children = new Map;\n\n    /** @type function */\n    this._get_list = async ? readdirAsync : readdir;\n    /** @type function */\n    this._get_stats = async ? statsAsync : stats;\n    /** @type function */\n    this._rm_dir = async ? rmdirAsync : rmdir;\n    /** @type function */\n    this._rm_file = async ? unlinkAsync : unlink;\n  }\n\n  /**\n   * @return {string}\n   */\n  get path() {\n    return this._path;\n  }\n\n  /**\n   * @return {string}\n   */\n  get basename() {\n    return path.basename(this._path);\n  }\n\n  /**\n   * @return {boolean}\n   */\n  get isDir() {\n    return this._stats.isDirectory();\n  }\n\n  /**\n   * @return {boolean}\n   */\n  get isRoot() {\n    return !this._parent;\n  }\n\n  /**\n   * @param {ExpireFS.TimeType} type\n   * @return {number}\n   */\n  getTime(type) {\n    return this._stats[type];\n  }\n\n  /**\n   * @return {number}\n   */\n  get size() {\n    return this._stats.size;\n  }\n\n  /**\n   * @return {Stats}\n   */\n  get stats() {\n    return this._stats;\n  }\n\n  /**\n   * @return {ExpireEntry}\n   */\n  get parent() {\n    return this._parent;\n  }\n\n  /**\n   * @return {Map<string, ExpireEntry>}\n   */\n  get children() {\n    return this._children;\n  }\n\n  /**\n   * @return {string[]}\n   */\n  get childrenList() {\n    return [...this._children.keys()];\n  }\n\n  get hasChildren() {\n    return this._children.size !== 0;\n  }\n\n  /**\n   * @return {ExpireEntry[]}\n   */\n  get childrenValues() {\n    return [...this._children.values()];\n  }\n\n  /**\n   * @return {Promise<void>}\n   */\n  async populate() {\n    try {\n      this._stats = await this._get_stats(this._path);\n    } catch (e) {\n      console.warn(`error reading stats for ${this._path}: ${e.message || e}`);\n      return;\n    }\n\n    if (!this.isDir) {\n      return;\n    }\n\n    let list = [];\n    try {\n      list = await this._get_list(this._path);\n    } catch (e) {\n      console.warn(`error reading dir listing for ${this._path}: ${e.message || e}`);\n      return;\n    }\n\n    const len = list.length;\n\n    const entries = [];\n    for (let i = 0; i < len; i++) {\n      const name = list[i];\n      if (name === '..' || name === '.') {\n        continue;\n      }\n\n      const entry = new ExpireEntry({\n        async: this._async,\n        path: path.join(this.path, name),\n        parent: this\n      });\n      entries.push(entry);\n      this.children.set(entry.basename, entry);\n    }\n\n    await Promise.all(entries.map(e => e.populate()));\n  }\n\n  /**\n   * @param {boolean=} keepEmptyParent\n   * @param {boolean=} dry\n   * @param {removeRoot=} dry\n   * @return {Promise<void>}\n   */\n  async delete({ keepEmptyParent = true, dry = false, removeRoot = false } = {}) {\n    debug_entry('deleting entry', this.path);\n\n    if (this.isDir) {\n      await Promise.all(\n        this.childrenValues.map(child => child.delete({\n          keepEmptyParent: true,\n          dry\n        })));\n\n      // check only remove if not root, or root and removeRoot===true\n      if (\n        !keepEmptyParent &&\n        (\n          !this.isRoot ||\n          (this.isRoot && removeRoot)\n        )\n      ) {\n\n        try {\n          await (\n            dry ?\n              console.log('del dir  ', this._path) :\n              this._rm_dir(this._path)\n          );\n        } catch (e) {\n          console.warn(`error deleting dir ${this._path}: ${e.message || e}`);\n          return;\n        }\n      }\n    } else {\n      try {\n        await (\n          dry ?\n            console.log('del file ', this.path) :\n            this._rm_file(this._path)\n        );\n      } catch (e) {\n        console.warn(`error deleting file ${this._path}: ${e.message || e}`);\n        return;\n      }\n    }\n\n    if (this.parent) {\n      this.parent.children.delete(this.basename);\n\n      if (!keepEmptyParent && this.parent.children.size === 0) {\n        await this.parent.delete({ keepEmptyParent, dry });\n      }\n    }\n  }\n\n  /**\n   * @param {function(ExpireEntry):void}callback\n   */\n  traverse(callback) {\n    const children = this.childrenValues;\n    const len = children.length;\n\n    for (let i = 0; i < len; i++) {\n      const c = children[i];\n      callback(c);\n\n      if (c.isDir) {\n        c.traverse(callback);\n      }\n    }\n  }\n\n  /**\n   * @param {function(ExpireEntry):Promise<void>}callback\n   * @return {Promise<void>}\n   */\n  async traverseAsync(callback) {\n    const children = this.childrenValues;\n    const len = children.length;\n\n    for (let i = 0; i < len; i++) {\n      const c = children[i];\n      await callback(c);\n\n      if (c.isDir) {\n        await c.traverseAsync(callback);\n      }\n    }\n  }\n\n  /**\n   * @return {ExpireEntry[]}\n   */\n  list() {\n    const list = [];\n\n    this.traverse((e) => {\n      list.push(e)\n    });\n\n    return list;\n  }\n}\n\n\nclass ExpireFS extends EventEmitter {\n\n  /**\n   * @param {String} folder\n   * @param {RegExp|function(String,Stats):Boolean=} filter\n   * @param {String=} [timeType='birthtime']\n   * @param {Number=} [expire=Infinity] - milliseconds\n   * @param {Number=} [pressure=1] - percentage of disk usage\n   * @param {Number=} [interval=300000] - milliseconds\n   * @param {Boolean=} [autoStart=true]\n   * @param {Boolean=} [unsafe=false]\n   * @param {Boolean=} [removeEmptyDirs=false]\n   * @param {Boolean=} [removeCleanedDirs=true]\n   * @param {Boolean=} [removeRoot=false]\n   * @param {Boolean=} [async=false]\n   * @param {Boolean=} [dry=false] - dry run\n   */\n  constructor({\n                folder,\n                unsafe = false,\n                timeType = 'birthtime',\n                filter = /.*/,\n                expire = Infinity,\n                pressure = 1,\n                interval = 5 * 60 * 1000,\n                autoStart = true,\n                removeEmptyDirs = false,\n                removeCleanedDirs = true,\n                removeRoot = false,\n                async = true,\n                dry = true,\n              }) {\n    super();\n\n    if (!folder) {\n      throw new Error('folder should be specified');\n    }\n    this.folder = path.resolve(folder);\n    if (!unsafe && this.folder.split(path.sep).length <= 2) {\n      throw new Error(\n        'Cowardly refusing to watch folder ' + folder + ' as it is a root folder. ' +\n        'To override this behaviour, please set \"unsafe\" to be true'\n      );\n    }\n\n    this.timeType = timeType;\n    if (!validTimeTypes.has(this.timeType)) {\n      throw new Error('timeType should be one of ' + [...validTimeTypes].join(', '));\n    }\n\n    this.filter = filter;\n    this.expire = expire;\n    this.pressure = pressure;\n    this.interval = interval;\n    this.autoStart = autoStart;\n    this.debug_expire = debug_expire;\n    this.debug_pressure = debug_pressure;\n\n    this.removeEmptyDirs = removeEmptyDirs;\n    this.removeCleanedDirs = removeCleanedDirs;\n    this.removeRoot = removeRoot;\n\n    this.dry = dry;\n\n    this._interval = null;\n\n    if (this.autoStart) {\n      this.start();\n    }\n\n    this._async = async;\n  }\n\n  /**\n   * @return {Promise<ExpireEntry>}\n   */\n  async list() {\n    const entry = new ExpireEntry({\n      async: this._async,\n      path: this.folder,\n      parent: null\n    });\n    await entry.populate();\n    return entry;\n  }\n\n  /**\n   * @param {String} path\n   * @param {Stats} stats\n   * @return {boolean}\n   * @private\n   */\n  _shouldDelete(path, stats) {\n    const time = stats[this.timeType];\n    // if regex check match (false)\n    if (this.filter instanceof RegExp && this.filter.test(path) === false) {\n      return false;\n    }\n    // if function check output (falsy)\n    if (typeof this.filter === 'function' && !this.filter(path, stats)) {\n      return false;\n    }\n    // if now - chosen time < expire time\n    if (Date.now() - time.getTime() < this.expire) {\n      return false;\n    }\n    // delete it\n    return true;\n  }\n\n  /**\n   * @param {ExpireEntry} entry\n   * @param {boolean} dry\n   * @return {Promise<ExpireEntry[]>}\n   * @private\n   */\n  async _expire({ entry, dry }) {\n    const list = entry.list();\n    const len = list.length;\n    const deleted = [];\n\n    for (let i = 0; i < len; i++) {\n      const e = list[i];\n\n      // remove empty dirs\n      if (this.removeEmptyDirs && e.isDir && !e.hasChildren) {\n        this.debug_expire('deleting empty dir', e.path);\n        await e.delete({\n          keepEmptyParent: !this.removeCleanedDirs,\n          dry,\n          removeRoot: this.removeRoot\n        });\n        deleted.push(e);\n      }\n\n      // if it's dir, continue\n      if (e.isDir) {\n        this.debug_expire('skipping dir', e.path);\n        continue;\n      }\n\n      // remove file is necessary\n      if (this._shouldDelete(e.path, e.stats)) {\n        this.debug_expire('deleting file', e.path);\n        await e.delete({\n          keepEmptyParent: !this.removeCleanedDirs,\n          dry,\n          removeRoot: this.removeRoot\n        });\n        deleted.push(e);\n      } else {\n        this.debug_expire('keeping file', e.path);\n      }\n    }\n    return deleted;\n  }\n\n  /**\n   * @param {ExpireEntry} entry\n   * @param {boolean} dry\n   * @return {Promise<ExpireEntry[]>}\n   * @private\n   */\n  async _pressure({ entry, dry }) {\n    const deleted = [];\n\n    const list = entry.list();\n    const disk = await (\n      this._async ?\n        diskusage.check(entry.path) :\n        diskusage.checkSync(entry.path)\n    );\n\n    const usagePerc = 1 - (disk.available / disk.total);\n\n    if (usagePerc < this.pressure) {\n      return [];\n    }\n\n    const shouldBe = disk.total * this.pressure;\n    let toFree = (disk.total - disk.available) - shouldBe;\n\n    debug_pressure(`disk usage is ${(usagePerc * 100).toFixed(2)}%`);\n    debug_pressure(`need to free ${pretty_size(toFree)}`);\n\n    // newest to oldest\n    list.sort((a, b) => b.getTime(this.timeType) - a.getTime(this.timeType));\n\n    while (list.length && toFree > 0) {\n      const item = list.pop();\n      if (item.isDir) {\n        continue;\n      }\n\n      toFree -= item.size;\n      await item.delete({ dry, keepEmptyParent: !this.removeCleanedDirs });\n      deleted.push(item);\n      debug_pressure(`freed ${pretty_size(item.size)} | left ${pretty_size(toFree)}`);\n    }\n    return deleted;\n  }\n\n  /**\n   * @param {boolean=}dry\n   * @return {Promise<ExpireEntry[]>}\n   */\n  async clean({ dry = this.dry } = {}) {\n    const entry = await this.list();\n    const deleted = [];\n    deleted.push(...await this._expire({ dry, entry }));\n    deleted.push(...await this._pressure({ dry, entry }));\n    this.emit('clean', deleted);\n    return deleted;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  stop() {\n    if (!this._interval) {\n      return false; // not started\n    }\n    clearInterval(this._interval);\n    this._interval = null;\n    return true;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  start() {\n    if (this._interval) {\n      return false; // already started\n    }\n    this._interval = setInterval(async () => {\n      try {\n        await this.clean();\n      } catch (e) {\n        this.emit('error', e);\n      }\n    }, this.interval);\n    return true;\n  }\n}\n\n/**\n *\n * @type {{access_time: string, modify_time: string, creation_time: string, birth_time: string}}\n */\nExpireFS.TimeType = {\n  access_time: 'atime',\n  modify_time: 'mtime',\n  creation_time: 'ctime',\n  birth_time: 'birthtime'\n};\n\nmodule.exports = ExpireFS;\n"]}