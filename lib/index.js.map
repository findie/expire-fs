{"version":3,"sources":["../src/index.js"],"names":["fs","require","path","EventEmitter","readdirAsync","dirname","Promise","res","rej","readdir","e","l","unlinkAsync","filename","unlink","statsAsync","stat","s","rmdirAsync","rmdir","validTimeTypes","ExpireFS","constructor","folder","unsafe","timeType","filter","expire","Infinity","interval","recursive","autoStart","removeEmptyDirs","Error","resolve","split","sep","length","indexOf","join","_interval","start","_shouldDelete","stats","time","RegExp","test","Date","now","getTime","_clean","dir","list","all","map","item","isDirectory","data","then","x","deleted","file","clean","emit","stop","clearInterval","setInterval","bind","module","exports"],"mappings":";;;;AAAA,MAAMA,KAAKC,QAAQ,IAAR,CAAX;AACA,MAAMC,OAAOD,QAAQ,MAAR,CAAb;AACA,MAAME,eAAeF,QAAQ,QAAR,CAArB;;AAEA,MAAMG,eAAeC,WAAW,IAAIC,OAAJ,CAAY,CAACC,GAAD,EAAMC,GAAN,KAAcR,GAAGS,OAAH,CAAWJ,OAAX,EAAoB,CAACK,CAAD,EAAIC,CAAJ,KAAUD,IAAIF,IAAIE,CAAJ,CAAJ,GAAaH,IAAII,CAAJ,CAA3C,CAA1B,CAAhC;AACA,MAAMC,cAAcC,YAAY,IAAIP,OAAJ,CAAY,CAACC,GAAD,EAAMC,GAAN,KAAcR,GAAGc,MAAH,CAAUD,QAAV,EAAoBH,KAAKA,IAAIF,IAAIE,CAAJ,CAAJ,GAAaH,KAAtC,CAA1B,CAAhC;AACA,MAAMQ,aAAaF,YAAY,IAAIP,OAAJ,CAAY,CAACC,GAAD,EAAMC,GAAN,KAAcR,GAAGgB,IAAH,CAAQH,QAAR,EAAkB,CAACH,CAAD,EAAIO,CAAJ,KAAUP,IAAIF,IAAIE,CAAJ,CAAJ,GAAaH,IAAIU,CAAJ,CAAzC,CAA1B,CAA/B;AACA,MAAMC,aAAaL,YAAY,IAAIP,OAAJ,CAAY,CAACC,GAAD,EAAMC,GAAN,KAAcR,GAAGmB,KAAH,CAASN,QAAT,EAAmBH,KAAKA,IAAIF,IAAIE,CAAJ,CAAJ,GAAaH,KAArC,CAA1B,CAA/B;;AAEA,MAAMa,iBAAiB,CAAC,OAAD,EAAU,OAAV,EAAmB,OAAnB,EAA4B,WAA5B,CAAvB;;AAEA,MAAMC,QAAN,SAAuBlB,YAAvB,CAAoC;;AAElC;;;;;;;;;;;;AAYAmB,cAAY;AACEC,UADF;AAEEC,aAAS,KAFX;AAGEC,eAAW,WAHb;AAIEC,aAAS,IAJX;AAKEC,aAASC,QALX;AAMEC,eAAW,IAAI,EAAJ,GAAS,IANtB;AAOEC,gBAAY,IAPd;AAQEC,gBAAY,IARd;AASEC,sBAAkB;AATpB,GAAZ,EAUe;AACb;;AAEA,QAAI,CAACT,MAAL,EAAa;AACX,YAAM,IAAIU,KAAJ,CAAU,4BAAV,CAAN;AACD;AACD,SAAKV,MAAL,GAAcrB,KAAKgC,OAAL,CAAaX,MAAb,CAAd;AACA,QAAI,CAACC,MAAD,IAAW,KAAKD,MAAL,CAAYY,KAAZ,CAAkBjC,KAAKkC,GAAvB,EAA4BC,MAA5B,IAAsC,CAArD,EAAwD;AACtD,YAAM,IAAIJ,KAAJ,CACJ,uCAAuCV,MAAvC,GAAgD,2BAAhD,GACA,4DAFI,CAAN;AAID;;AAED,SAAKE,QAAL,GAAgBA,QAAhB;AACA,QAAI,CAAC,CAACL,eAAekB,OAAf,CAAuB,KAAKb,QAA5B,CAAN,EAA6C;AAC3C,YAAM,IAAIQ,KAAJ,CAAU,+BAA+Bb,eAAemB,IAAf,CAAoB,IAApB,CAAzC,CAAN;AACD;;AAED,SAAKb,MAAL,GAAcA,MAAd;AACA,SAAKC,MAAL,GAAcA,MAAd;;AAEA,SAAKE,QAAL,GAAgBA,QAAhB;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACA,SAAKC,SAAL,GAAiBA,SAAjB;;AAEA,SAAKC,eAAL,GAAuBA,eAAvB;;AAEA,SAAKQ,SAAL,GAAiB,IAAjB;;AAEA,QAAI,KAAKT,SAAT,EAAoB;AAClB,WAAKU,KAAL;AACD;AACF;;AAED;;;;;;AAMAC,gBAAcxC,IAAd,EAAoByC,KAApB,EAA2B;AACzB,UAAMC,OAAOD,MAAM,KAAKlB,QAAX,CAAb;AACA;AACA,QAAI,KAAKC,MAAL,YAAuBmB,MAAvB,IAAiC,KAAKnB,MAAL,CAAYoB,IAAZ,CAAiB5C,IAAjB,MAA2B,KAAhE,EAAuE;AACrE,aAAO,KAAP;AACD;AACD;AACA,QAAI,OAAO,KAAKwB,MAAZ,KAAuB,UAAvB,IAAqC,CAAC,KAAKA,MAAL,CAAYxB,IAAZ,EAAkByC,KAAlB,CAA1C,EAAoE;AAClE,aAAO,KAAP;AACD;AACD;AACA,QAAII,KAAKC,GAAL,KAAaJ,KAAKK,OAAL,EAAb,GAA8B,KAAKtB,MAAvC,EAA+C;AAC7C,aAAO,KAAP;AACD;AACD;AACA,WAAO,IAAP;AACD;;AAED;;;;;;;AAOA;;;;;;;AAOA;;;;;AAKMuB,QAAN,CAAaC,GAAb,EAAkB;AAAA;;AAAA;;AAEhB,YAAMC,OAAO,MAAMhD,aAAa+C,GAAb,CAAnB;;AAEA,aAAO,MAAM7C,QAAQ+C,GAAR,CAAYD,KACtBE,GADsB,CAClB;AAAA,eAAQpD,KAAKqC,IAAL,CAAUY,GAAV,EAAeI,IAAf,CAAR;AAAA,OADkB,EAEtBD,GAFsB;AAAA,qCAElB,WAAMpD,IAAN,EAAc;AACjB,gBAAMyC,QAAQ,MAAM5B,WAAWb,IAAX,CAApB;;AAEA,cAAI,MAAK4B,SAAL,IAAkBa,MAAMa,WAAN,EAAlB,IAAyCtD,SAAS,GAAlD,IAAyDA,SAAS,IAAtE,EAA4E;AAC1E,kBAAMuD,OAAO,MAAM,MAAKP,MAAL,CAAYhD,IAAZ,EAAkBwD,IAAlB,CAAuB;AAAA,qBAAM,EAAExD,IAAF,EAAQkD,MAAMO,CAAd,EAAiBpC,QAAQ,IAAzB,EAAN;AAAA,aAAvB,CAAnB,CAD0E,CACS;AACnF,gBAAI,MAAKS,eAAL,IAAwB,CAAC,MAAM5B,aAAaF,IAAb,CAAP,EAA2BmC,MAA3B,KAAsC,CAAlE,EAAqE;AACnE,oBAAMnB,WAAWhB,IAAX,CAAN;AACD;AACD,mBAAOuD,IAAP;AACD;;AAED,cAAI,CAACd,MAAMa,WAAN,EAAD,IAAwB,MAAKd,aAAL,CAAmBxC,IAAnB,EAAyByC,KAAzB,MAAoC,IAAhE,EAAsE;AACpE,mBAAO,MAAM/B,YAAYV,IAAZ,EAAkBwD,IAAlB,CAAuB;AAAA,qBAAM,EAAExD,IAAF,EAAQ0D,SAAS,IAAjB,EAAuBC,MAAM,IAA7B,EAAN;AAAA,aAAvB,CAAb,CADoE,CACa;AAClF;;AAED,iBAAO,EAAE3D,IAAF,EAAQ0D,SAAS,KAAjB,EAAP;AACD,SAlBsB;;AAAA;AAAA;AAAA;AAAA,WAAZ,CAAb;AAJgB;AAwBjB;;AAED;;;AAGME,OAAN,GAAc;AAAA;;AAAA;AACZ,YAAML,OAAO,MAAM,OAAKP,MAAL,CAAY,OAAK3B,MAAjB,CAAnB;AACA,aAAKwC,IAAL,CAAU,OAAV,EAAmBN,IAAnB;AACA,aAAOA,IAAP;AAHY;AAIb;;AAED;;;AAGAO,SAAO;AACL,QAAI,CAAC,KAAKxB,SAAV,EAAqB;AACnB,aAAO,KAAP,CADmB,CACL;AACf;AACDyB,kBAAc,KAAKzB,SAAnB;AACA,SAAKA,SAAL,GAAiB,IAAjB;AACA,WAAO,IAAP;AACD;;AAED;;;AAGAC,UAAQ;AACN,QAAI,KAAKD,SAAT,EAAoB;AAClB,aAAO,KAAP,CADkB,CACJ;AACf;AACD,SAAKA,SAAL,GAAiB0B,YAAY,KAAKJ,KAAL,CAAWK,IAAX,CAAgB,IAAhB,CAAZ,EAAmC,KAAKtC,QAAxC,CAAjB;AACA,WAAO,IAAP;AACD;AA9JiC;;AAiKpCuC,OAAOC,OAAP,GAAiBhD,QAAjB","file":"index.js","sourcesContent":["const fs = require('fs');\nconst path = require('path');\nconst EventEmitter = require('events');\n\nconst readdirAsync = dirname => new Promise((res, rej) => fs.readdir(dirname, (e, l) => e ? rej(e) : res(l)));\nconst unlinkAsync = filename => new Promise((res, rej) => fs.unlink(filename, e => e ? rej(e) : res()));\nconst statsAsync = filename => new Promise((res, rej) => fs.stat(filename, (e, s) => e ? rej(e) : res(s)));\nconst rmdirAsync = filename => new Promise((res, rej) => fs.rmdir(filename, e => e ? rej(e) : res()));\n\nconst validTimeTypes = ['atime', 'mtime', 'ctime', 'birthtime'];\n\nclass ExpireFS extends EventEmitter {\n\n  /**\n   * @param options\n   * @param {String} options.folder\n   * @param {RegExp|function(String,Stats):Boolean=} options.filter\n   * @param {String=} [options.timeType='birthtime']\n   * @param {Number=} [options.expire=Infinity] - milliseconds\n   * @param {Number=} [options.interval=300000] - milliseconds\n   * @param {Boolean=} [options.recursive=true]\n   * @param {Boolean=} [options.autoStart=true]\n   * @param {Boolean=} [options.unsafe=false]\n   * @param {Boolean=} [options.removeEmptyDirs=false]\n   */\n  constructor({\n                folder,\n                unsafe = false,\n                timeType = 'birthtime',\n                filter = /.*/,\n                expire = Infinity,\n                interval = 5 * 60 * 1000,\n                recursive = true,\n                autoStart = true,\n                removeEmptyDirs = true\n              }) {\n    super();\n\n    if (!folder) {\n      throw new Error('folder should be specified');\n    }\n    this.folder = path.resolve(folder);\n    if (!unsafe && this.folder.split(path.sep).length <= 2) {\n      throw new Error(\n        'Cowardly refusing to watch folder ' + folder + ' as it is a root folder. ' +\n        'To override this behaviour, please set \"unsafe\" to be true'\n      );\n    }\n\n    this.timeType = timeType;\n    if (!~validTimeTypes.indexOf(this.timeType)) {\n      throw new Error('timeType should be one of ' + validTimeTypes.join(', '));\n    }\n\n    this.filter = filter;\n    this.expire = expire;\n\n    this.interval = interval;\n    this.recursive = recursive;\n    this.autoStart = autoStart;\n\n    this.removeEmptyDirs = removeEmptyDirs;\n\n    this._interval = null;\n\n    if (this.autoStart) {\n      this.start();\n    }\n  }\n\n  /**\n   * @param {String} path\n   * @param {Stats} stats\n   * @return {boolean}\n   * @private\n   */\n  _shouldDelete(path, stats) {\n    const time = stats[this.timeType];\n    // if regex check match (false)\n    if (this.filter instanceof RegExp && this.filter.test(path) === false) {\n      return false;\n    }\n    // if function check output (falsy)\n    if (typeof this.filter === 'function' && !this.filter(path, stats)) {\n      return false;\n    }\n    // if now - chosen time < expire time\n    if (Date.now() - time.getTime() < this.expire) {\n      return false;\n    }\n    // delete it\n    return true;\n  }\n\n  /**\n   * @typedef {Object} ExpireFSFolderFile\n   * @property {String} path\n   * @property {Boolean} deleted\n   * @property {Boolean} file\n   */\n\n  /**\n   * @typedef {Object} ExpireFSFolderChain\n   * @property {String} path\n   * @property {Boolean} folder\n   * @property {Array.<ExpireFSFolderFile|ExpireFSFolderChain>}} list\n   */\n\n  /**\n   * @param {String} dir\n   * @return {PromiseLike<ExpireFSFolderChain[]> | Promise<ExpireFSFolderChain[]>}\n   * @private\n   */\n  async _clean(dir) {\n\n    const list = await readdirAsync(dir);\n\n    return await Promise.all(list\n      .map(item => path.join(dir, item))\n      .map(async path => {\n        const stats = await statsAsync(path);\n\n        if (this.recursive && stats.isDirectory() && path !== '.' && path !== '..') {\n          const data = await this._clean(path).then(x => ({ path, list: x, folder: true })); // recursive on next dir\n          if (this.removeEmptyDirs && (await readdirAsync(path)).length === 0) {\n            await rmdirAsync(path);\n          }\n          return data;\n        }\n\n        if (!stats.isDirectory() && this._shouldDelete(path, stats) === true) {\n          return await unlinkAsync(path).then(x => ({ path, deleted: true, file: true })); // delete file\n        }\n\n        return { path, deleted: false }\n      })\n    );\n  }\n\n  /**\n   * @return {PromiseLike<ExpireFSFolderChain[]> | Promise<ExpireFSFolderChain[]>}\n   */\n  async clean() {\n    const data = await this._clean(this.folder)\n    this.emit('clean', data);\n    return data;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  stop() {\n    if (!this._interval) {\n      return false; // not started\n    }\n    clearInterval(this._interval);\n    this._interval = null;\n    return true;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  start() {\n    if (this._interval) {\n      return false; // already started\n    }\n    this._interval = setInterval(this.clean.bind(this), this.interval);\n    return true;\n  }\n}\n\nmodule.exports = ExpireFS;\n"]}