{"version":3,"sources":["../src/index.js"],"names":["fs","require","path","EventEmitter","readdirAsync","dirname","Promise","res","rej","readdir","e","l","unlinkAsync","filename","unlink","statsAsync","stat","s","rmdirAsync","rmdir","ignoreENOENT","fn","args","code","undefined","validTimeTypes","ExpireFS","constructor","folder","unsafe","timeType","filter","expire","Infinity","interval","recursive","autoStart","removeEmptyDirs","removeCleanedDirs","Error","resolve","split","sep","length","indexOf","join","_interval","start","_shouldDelete","stats","time","RegExp","test","Date","now","getTime","_clean","dir","list","all","map","item","deleted","isDirectory","data","then","x","file","clean","emit","stop","clearInterval","setInterval","module","exports"],"mappings":";;;;AAAA,MAAMA,KAAKC,QAAQ,IAAR,CAAX;AACA,MAAMC,OAAOD,QAAQ,MAAR,CAAb;AACA,MAAME,eAAeF,QAAQ,QAAR,CAArB;;AAEA,MAAMG,eAAeC,WAAW,IAAIC,OAAJ,CAAY,CAACC,GAAD,EAAMC,GAAN,KAAcR,GAAGS,OAAH,CAAWJ,OAAX,EAAoB,CAACK,CAAD,EAAIC,CAAJ,KAAUD,IAAIF,IAAIE,CAAJ,CAAJ,GAAaH,IAAII,CAAJ,CAA3C,CAA1B,CAAhC;AACA,MAAMC,cAAcC,YAAY,IAAIP,OAAJ,CAAY,CAACC,GAAD,EAAMC,GAAN,KAAcR,GAAGc,MAAH,CAAUD,QAAV,EAAoBH,KAAKA,IAAIF,IAAIE,CAAJ,CAAJ,GAAaH,KAAtC,CAA1B,CAAhC;AACA,MAAMQ,aAAaF,YAAY,IAAIP,OAAJ,CAAY,CAACC,GAAD,EAAMC,GAAN,KAAcR,GAAGgB,IAAH,CAAQH,QAAR,EAAkB,CAACH,CAAD,EAAIO,CAAJ,KAAUP,IAAIF,IAAIE,CAAJ,CAAJ,GAAaH,IAAIU,CAAJ,CAAzC,CAA1B,CAA/B;AACA,MAAMC,aAAaL,YAAY,IAAIP,OAAJ,CAAY,CAACC,GAAD,EAAMC,GAAN,KAAcR,GAAGmB,KAAH,CAASN,QAAT,EAAmBH,KAAKA,IAAIF,IAAIE,CAAJ,CAAJ,GAAaH,KAArC,CAA1B,CAA/B;;AAEA,MAAMa;AAAA,+BAAe,WAAOC,EAAP,EAAW,GAAGC,IAAd,EAAuB;AAC1C,QAAI;AACF,aAAO,MAAMD,GAAG,GAAGC,IAAN,CAAb;AACD,KAFD,CAEE,OAAOZ,CAAP,EAAU;AACV,UAAIA,EAAEa,IAAF,KAAW,QAAf,EAAyB;AACvB,eAAOC,SAAP;AACD;AACD,YAAMd,CAAN;AACD;AACF,GATK;;AAAA;AAAA;AAAA;AAAA,IAAN;;AAWA,MAAMe,iBAAiB,CAAC,OAAD,EAAU,OAAV,EAAmB,OAAnB,EAA4B,WAA5B,CAAvB;;AAEA,MAAMC,QAAN,SAAuBvB,YAAvB,CAAoC;;AAElC;;;;;;;;;;;;AAYAwB,cAAY;AACEC,UADF;AAEEC,aAAS,KAFX;AAGEC,eAAW,WAHb;AAIEC,aAAS,IAJX;AAKEC,aAASC,QALX;AAMEC,eAAW,IAAI,EAAJ,GAAS,IANtB;AAOEC,gBAAY,IAPd;AAQEC,gBAAY,IARd;AASEC,sBAAkB,KATpB;AAUEC,wBAAoB;AAVtB,GAAZ,EAWe;AACb;;AAEA,QAAI,CAACV,MAAL,EAAa;AACX,YAAM,IAAIW,KAAJ,CAAU,4BAAV,CAAN;AACD;AACD,SAAKX,MAAL,GAAc1B,KAAKsC,OAAL,CAAaZ,MAAb,CAAd;AACA,QAAI,CAACC,MAAD,IAAW,KAAKD,MAAL,CAAYa,KAAZ,CAAkBvC,KAAKwC,GAAvB,EAA4BC,MAA5B,IAAsC,CAArD,EAAwD;AACtD,YAAM,IAAIJ,KAAJ,CACJ,uCAAuCX,MAAvC,GAAgD,2BAAhD,GACA,4DAFI,CAAN;AAID;;AAED,SAAKE,QAAL,GAAgBA,QAAhB;AACA,QAAI,CAAC,CAACL,eAAemB,OAAf,CAAuB,KAAKd,QAA5B,CAAN,EAA6C;AAC3C,YAAM,IAAIS,KAAJ,CAAU,+BAA+Bd,eAAeoB,IAAf,CAAoB,IAApB,CAAzC,CAAN;AACD;;AAED,SAAKd,MAAL,GAAcA,MAAd;AACA,SAAKC,MAAL,GAAcA,MAAd;;AAEA,SAAKE,QAAL,GAAgBA,QAAhB;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACA,SAAKC,SAAL,GAAiBA,SAAjB;;AAEA,SAAKC,eAAL,GAAuBA,eAAvB;AACA,SAAKC,iBAAL,GAAyBA,iBAAzB;;AAEA,SAAKQ,SAAL,GAAiB,IAAjB;;AAEA,QAAI,KAAKV,SAAT,EAAoB;AAClB,WAAKW,KAAL;AACD;AACF;;AAED;;;;;;AAMAC,gBAAc9C,IAAd,EAAoB+C,KAApB,EAA2B;AACzB,UAAMC,OAAOD,MAAM,KAAKnB,QAAX,CAAb;AACA;AACA,QAAI,KAAKC,MAAL,YAAuBoB,MAAvB,IAAiC,KAAKpB,MAAL,CAAYqB,IAAZ,CAAiBlD,IAAjB,MAA2B,KAAhE,EAAuE;AACrE,aAAO,KAAP;AACD;AACD;AACA,QAAI,OAAO,KAAK6B,MAAZ,KAAuB,UAAvB,IAAqC,CAAC,KAAKA,MAAL,CAAY7B,IAAZ,EAAkB+C,KAAlB,CAA1C,EAAoE;AAClE,aAAO,KAAP;AACD;AACD;AACA,QAAII,KAAKC,GAAL,KAAaJ,KAAKK,OAAL,EAAb,GAA8B,KAAKvB,MAAvC,EAA+C;AAC7C,aAAO,KAAP;AACD;AACD;AACA,WAAO,IAAP;AACD;;AAED;;;;;;;AAOA;;;;;;;AAOA;;;;;AAKMwB,QAAN,CAAaC,GAAb,EAAkB;AAAA;;AAAA;;AAEhB,YAAMC,OAAO,MAAMtD,aAAaqD,GAAb,CAAnB;;AAEA,aAAO,MAAMnD,QAAQqD,GAAR,CAAYD,KACtBE,GADsB,CAClB;AAAA,eAAQ1D,KAAK2C,IAAL,CAAUY,GAAV,EAAeI,IAAf,CAAR;AAAA,OADkB,EAEtBD,GAFsB;AAAA,sCAElB,WAAM1D,IAAN,EAAc;AACjB,gBAAM+C,QAAQ,MAAM7B,aAAaL,UAAb,EAAyBb,IAAzB,CAApB;AACA,cAAG,CAAC+C,KAAJ,EAAU;AACR;AACA,mBAAO,EAAE/C,IAAF,EAAQ4D,SAAS,KAAjB,EAAP;AACD;;AAED,cAAI,MAAK3B,SAAL,IAAkBc,MAAMc,WAAN,EAAlB,IAAyC7D,SAAS,GAAlD,IAAyDA,SAAS,IAAtE,EAA4E;AAC1E,kBAAM8D,OAAO,MAAM,MAAKR,MAAL,CAAYtD,IAAZ,EAAkB+D,IAAlB,CAAuB;AAAA,qBAAM,EAAE/D,IAAF,EAAQwD,MAAMQ,CAAd,EAAiBtC,QAAQ,IAAzB,EAAN;AAAA,aAAvB,CAAnB,CAD0E,CACS;;AAEnF;AACA,gBAAI,CAAC,MAAMxB,aAAaF,IAAb,CAAP,EAA2ByC,MAA3B,KAAsC,CAA1C,EAA6C;;AAE3C;AACA,kBAAI,MAAKN,eAAT,EAA0B;AACxB;AACA,sBAAMnB,WAAWhB,IAAX,CAAN;AACD;AACD;AAJA,mBAKK,IAAI,MAAKoC,iBAAL,IAA0B0B,KAAKN,IAAL,CAAUf,MAAV,GAAmB,CAAjD,EAAoD;AACvD;AACA,wBAAMzB,WAAWhB,IAAX,CAAN;AACD;AAEF;AACD,mBAAO8D,IAAP;AACD;;AAED,cAAI,CAACf,MAAMc,WAAN,EAAD,IAAwB,MAAKf,aAAL,CAAmB9C,IAAnB,EAAyB+C,KAAzB,MAAoC,IAAhE,EAAsE;AACpE,mBAAO,MAAMrC,YAAYV,IAAZ,EAAkB+D,IAAlB,CAAuB;AAAA,qBAAM,EAAE/D,IAAF,EAAQ4D,SAAS,IAAjB,EAAuBK,MAAM,IAA7B,EAAN;AAAA,aAAvB,CAAb,CADoE,CACa;AAClF;;AAED,iBAAO,EAAEjE,IAAF,EAAQ4D,SAAS,KAAjB,EAAP;AACD,SAnCsB;;AAAA;AAAA;AAAA;AAAA,WAAZ,CAAb;AAJgB;AAyCjB;;AAED;;;AAGMM,OAAN,GAAc;AAAA;;AAAA;AACZ,YAAMJ,OAAO,MAAM,OAAKR,MAAL,CAAY,OAAK5B,MAAjB,CAAnB;AACA,aAAKyC,IAAL,CAAU,OAAV,EAAmBL,IAAnB;AACA,aAAOA,IAAP;AAHY;AAIb;;AAED;;;AAGAM,SAAO;AACL,QAAI,CAAC,KAAKxB,SAAV,EAAqB;AACnB,aAAO,KAAP,CADmB,CACL;AACf;AACDyB,kBAAc,KAAKzB,SAAnB;AACA,SAAKA,SAAL,GAAiB,IAAjB;AACA,WAAO,IAAP;AACD;;AAED;;;AAGAC,UAAQ;AAAA;;AACN,QAAI,KAAKD,SAAT,EAAoB;AAClB,aAAO,KAAP,CADkB,CACJ;AACf;AACD,SAAKA,SAAL,GAAiB0B,8BAAY,aAAY;AACvC,UAAI;AACF,cAAM,OAAKJ,KAAL,EAAN;AACD,OAFD,CAEE,OAAO1D,CAAP,EAAU;AACV,eAAK2D,IAAL,CAAU,OAAV,EAAmB3D,CAAnB;AACD;AACF,KANgB,GAMd,KAAKwB,QANS,CAAjB;AAOA,WAAO,IAAP;AACD;AAvLiC;;AA0LpCuC,OAAOC,OAAP,GAAiBhD,QAAjB","file":"index.js","sourcesContent":["const fs = require('fs');\nconst path = require('path');\nconst EventEmitter = require('events');\n\nconst readdirAsync = dirname => new Promise((res, rej) => fs.readdir(dirname, (e, l) => e ? rej(e) : res(l)));\nconst unlinkAsync = filename => new Promise((res, rej) => fs.unlink(filename, e => e ? rej(e) : res()));\nconst statsAsync = filename => new Promise((res, rej) => fs.stat(filename, (e, s) => e ? rej(e) : res(s)));\nconst rmdirAsync = filename => new Promise((res, rej) => fs.rmdir(filename, e => e ? rej(e) : res()));\n\nconst ignoreENOENT = async (fn, ...args) => {\n  try {\n    return await fn(...args);\n  } catch (e) {\n    if (e.code === 'ENOENT') {\n      return undefined;\n    }\n    throw e;\n  }\n};\n\nconst validTimeTypes = ['atime', 'mtime', 'ctime', 'birthtime'];\n\nclass ExpireFS extends EventEmitter {\n\n  /**\n   * @param options\n   * @param {String} options.folder\n   * @param {RegExp|function(String,Stats):Boolean=} options.filter\n   * @param {String=} [options.timeType='birthtime']\n   * @param {Number=} [options.expire=Infinity] - milliseconds\n   * @param {Number=} [options.interval=300000] - milliseconds\n   * @param {Boolean=} [options.recursive=true]\n   * @param {Boolean=} [options.autoStart=true]\n   * @param {Boolean=} [options.unsafe=false]\n   * @param {Boolean=} [options.removeEmptyDirs=false]\n   */\n  constructor({\n                folder,\n                unsafe = false,\n                timeType = 'birthtime',\n                filter = /.*/,\n                expire = Infinity,\n                interval = 5 * 60 * 1000,\n                recursive = true,\n                autoStart = true,\n                removeEmptyDirs = false,\n                removeCleanedDirs = true\n              }) {\n    super();\n\n    if (!folder) {\n      throw new Error('folder should be specified');\n    }\n    this.folder = path.resolve(folder);\n    if (!unsafe && this.folder.split(path.sep).length <= 2) {\n      throw new Error(\n        'Cowardly refusing to watch folder ' + folder + ' as it is a root folder. ' +\n        'To override this behaviour, please set \"unsafe\" to be true'\n      );\n    }\n\n    this.timeType = timeType;\n    if (!~validTimeTypes.indexOf(this.timeType)) {\n      throw new Error('timeType should be one of ' + validTimeTypes.join(', '));\n    }\n\n    this.filter = filter;\n    this.expire = expire;\n\n    this.interval = interval;\n    this.recursive = recursive;\n    this.autoStart = autoStart;\n\n    this.removeEmptyDirs = removeEmptyDirs;\n    this.removeCleanedDirs = removeCleanedDirs;\n\n    this._interval = null;\n\n    if (this.autoStart) {\n      this.start();\n    }\n  }\n\n  /**\n   * @param {String} path\n   * @param {Stats} stats\n   * @return {boolean}\n   * @private\n   */\n  _shouldDelete(path, stats) {\n    const time = stats[this.timeType];\n    // if regex check match (false)\n    if (this.filter instanceof RegExp && this.filter.test(path) === false) {\n      return false;\n    }\n    // if function check output (falsy)\n    if (typeof this.filter === 'function' && !this.filter(path, stats)) {\n      return false;\n    }\n    // if now - chosen time < expire time\n    if (Date.now() - time.getTime() < this.expire) {\n      return false;\n    }\n    // delete it\n    return true;\n  }\n\n  /**\n   * @typedef {Object} ExpireFSFolderFile\n   * @property {String} path\n   * @property {Boolean} deleted\n   * @property {Boolean} file\n   */\n\n  /**\n   * @typedef {Object} ExpireFSFolderChain\n   * @property {String} path\n   * @property {Boolean} folder\n   * @property {Array.<ExpireFSFolderFile|ExpireFSFolderChain>}} list\n   */\n\n  /**\n   * @param {String} dir\n   * @return {PromiseLike<ExpireFSFolderChain[]> | Promise<ExpireFSFolderChain[]>}\n   * @private\n   */\n  async _clean(dir) {\n\n    const list = await readdirAsync(dir);\n\n    return await Promise.all(list\n      .map(item => path.join(dir, item))\n      .map(async path => {\n        const stats = await ignoreENOENT(statsAsync, path);\n        if(!stats){\n          // it's been already deleted\n          return { path, deleted: false }\n        }\n\n        if (this.recursive && stats.isDirectory() && path !== '.' && path !== '..') {\n          const data = await this._clean(path).then(x => ({ path, list: x, folder: true })); // recursive on next dir\n\n          // if dir is empty\n          if ((await readdirAsync(path)).length === 0) {\n\n            // and if we want to delete empty dirs\n            if (this.removeEmptyDirs) {\n              // delete dir\n              await rmdirAsync(path);\n            }\n            // and if we want to delete only dirs that have been cleaned up\n            else if (this.removeCleanedDirs && data.list.length > 0) {\n              // delete dir\n              await rmdirAsync(path);\n            }\n\n          }\n          return data;\n        }\n\n        if (!stats.isDirectory() && this._shouldDelete(path, stats) === true) {\n          return await unlinkAsync(path).then(x => ({ path, deleted: true, file: true })); // delete file\n        }\n\n        return { path, deleted: false }\n      })\n    );\n  }\n\n  /**\n   * @return {PromiseLike<ExpireFSFolderChain[]> | Promise<ExpireFSFolderChain[]>}\n   */\n  async clean() {\n    const data = await this._clean(this.folder);\n    this.emit('clean', data);\n    return data;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  stop() {\n    if (!this._interval) {\n      return false; // not started\n    }\n    clearInterval(this._interval);\n    this._interval = null;\n    return true;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  start() {\n    if (this._interval) {\n      return false; // already started\n    }\n    this._interval = setInterval(async () => {\n      try {\n        await this.clean();\n      } catch (e) {\n        this.emit('error', e);\n      }\n    }, this.interval);\n    return true;\n  }\n}\n\nmodule.exports = ExpireFS;\n"]}