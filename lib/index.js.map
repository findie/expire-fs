{"version":3,"sources":["../src/index.js"],"names":["fs","require","path","EventEmitter","readdirAsync","dirname","Promise","res","rej","readdir","e","l","unlinkAsync","filename","unlink","statsAsync","stat","s","rmdirAsync","rmdir","readdirSync","unlinkSync","stats","statSync","rmdirSync","ignoreENOENT","fn","args","code","undefined","validTimeTypes","ExpireEntry","constructor","async","parent","_path","_async","_stats","_parent","_children","Map","_get_list","_get_stats","_rm_dir","_rm_file","basename","isDir","isDirectory","getTime","type","size","children","childrenList","keys","hasChildren","childrenValues","values","populate","list","len","length","entries","i","name","entry","join","push","set","all","map","delete","keepEmptyParent","dry","child","console","log","traverse","callback","c","traverseAsync","ExpireFS","folder","unsafe","timeType","filter","expire","Infinity","interval","autoStart","removeEmptyDirs","removeCleanedDirs","Error","resolve","split","sep","indexOf","_interval","start","_readdir","_unlink","_rmdir","_shouldDelete","time","RegExp","test","Date","now","clean","emit","stop","clearInterval","setInterval","TimeType","access_time","modify_time","creation_time","birth_time","module","exports"],"mappings":"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","file":"index.js","sourcesContent":["const fs = require('fs');\nconst path = require('path');\nconst EventEmitter = require('events');\n\nconst readdirAsync = dirname => new Promise((res, rej) => fs.readdir(dirname, (e, l) => e ? rej(e) : res(l)));\nconst unlinkAsync = filename => new Promise((res, rej) => fs.unlink(filename, e => e ? rej(e) : res()));\nconst statsAsync = filename => new Promise((res, rej) => fs.stat(filename, (e, s) => e ? rej(e) : res(s)));\nconst rmdirAsync = filename => new Promise((res, rej) => fs.rmdir(filename, e => e ? rej(e) : res()));\n\nconst readdir = filename => fs.readdirSync(filename);\nconst unlink = filename => fs.unlinkSync(filename);\nconst stats = filename => fs.statSync(filename);\nconst rmdir = filename => fs.rmdirSync(filename);\n\nconst ignoreENOENT = async (fn, ...args) => {\n  try {\n    return await fn(...args);\n  } catch (e) {\n    if (e.code === 'ENOENT') {\n      return undefined;\n    }\n    throw e;\n  }\n};\n\nconst validTimeTypes = ['atime', 'mtime', 'ctime', 'birthtime'];\n\nclass ExpireEntry {\n  /**\n   * @param {boolean} async\n   * @param {string} path\n   * @param {ExpireEntry|null} parent\n   */\n  constructor({ async = false, path, parent }) {\n    this._path = path;\n    this._async = async;\n    /**\n     * @type {Stats}\n     * @private\n     */\n    this._stats = null;\n\n    this._parent = parent;\n    /**\n     * @type {Map<string, ExpireEntry>}\n     * @private\n     */\n    this._children = new Map;\n\n    /** @type function */\n    this._get_list = async ? readdirAsync : readdir;\n    /** @type function */\n    this._get_stats = async ? statsAsync : stats;\n    /** @type function */\n    this._rm_dir = async ? rmdirAsync : rmdir;\n    /** @type function */\n    this._rm_file = async ? unlinkAsync : unlink;\n  }\n\n  /**\n   * @return {string}\n   */\n  get path() {\n    return this._path;\n  }\n\n  /**\n   * @return {string}\n   */\n  get basename() {\n    return path.basename(this._path);\n  }\n\n  /**\n   * @return {boolean}\n   */\n  get isDir() {\n    return this._stats.isDirectory();\n  }\n\n  /**\n   * @param {ExpireFS.TimeType} type\n   * @return {number}\n   */\n  getTime(type) {\n    return this._stats[type];\n  }\n\n  /**\n   * @return {number}\n   */\n  get size() {\n    return this._stats.size;\n  }\n\n  /**\n   * @return {Stats}\n   */\n  get stats() {\n    return this._stats;\n  }\n\n  /**\n   * @return {ExpireEntry}\n   */\n  get parent() {\n    return this._parent;\n  }\n\n  /**\n   * @return {Map<string, ExpireEntry>}\n   */\n  get children() {\n    return this._children;\n  }\n\n  /**\n   * @return {string[]}\n   */\n  get childrenList() {\n    return [...this._children.keys()];\n  }\n\n  get hasChildren() {\n    return this._children.size !== 0;\n  }\n\n  /**\n   * @return {ExpireEntry[]}\n   */\n  get childrenValues() {\n    return [...this._children.values()];\n  }\n\n  /**\n   * @return {Promise<void>}\n   */\n  async populate() {\n    this._stats = await this._get_stats(this._path);\n\n    if (!this.isDir) {\n      return;\n    }\n\n    const list = await this._get_list(this._path);\n    const len = list.length;\n\n    const entries = [];\n    for (let i = 0; i < len; i++) {\n      const name = list[i];\n      if (name === '..' || name === '.') {\n        continue;\n      }\n\n      const entry = new ExpireEntry({\n        async: this._async,\n        path: path.join(this.path, name),\n        parent: this\n      });\n      entries.push(entry);\n      this.children.set(entry.basename, entry);\n    }\n\n    await Promise.all(entries.map(e => e.populate()));\n  }\n\n  /**\n   * @param {boolean=} keepEmptyParent\n   * @param {boolean=} dry\n   * @return {Promise<void>}\n   */\n  async delete({ keepEmptyParent = true, dry = false } = {}) {\n    if (this.isDir) {\n      await Promise.all(\n        this.childrenValues.map(child => child.delete({\n          keepEmptyParent: true,\n          dry\n        })));\n      if (!keepEmptyParent) {\n        await dry ?\n          console.log('del dir  ', this._path) :\n          this._rm_dir(this._path);\n      }\n    } else {\n      await dry ?\n        console.log('del file ', this.path) :\n        this._rm_file(this._path);\n    }\n\n    if (this.parent) {\n      this.parent.children.delete(this.basename);\n\n      if (!keepEmptyParent && this.parent.children.size === 0) {\n        await this.parent.delete({ keepEmptyParent, dry });\n      }\n    }\n  }\n\n  /**\n   * @param {function(ExpireEntry):void}callback\n   */\n  traverse(callback) {\n    const children = this.childrenValues;\n    const len = children.length;\n\n    for (let i = 0; i < len; i++) {\n      const c = children[i];\n      callback(c);\n\n      if (c.isDir) {\n        c.traverse(callback);\n      }\n    }\n  }\n\n  /**\n   * @param {function(ExpireEntry):Promise<void>}callback\n   * @return {Promise<void>}\n   */\n  async traverseAsync(callback) {\n    const children = this.childrenValues;\n    const len = children.length;\n\n    for (let i = 0; i < len; i++) {\n      const c = children[i];\n      await callback(c);\n\n      if (c.isDir) {\n        await c.traverseAsync(callback);\n      }\n    }\n  }\n\n  /**\n   * @return {ExpireEntry[]}\n   */\n  list() {\n    const list = [];\n\n    this.traverse((e) => {\n      list.push(e)\n    });\n\n    return list;\n  }\n}\n\n\nclass ExpireFS extends EventEmitter {\n\n  /**\n   * @param options\n   * @param {String} options.folder\n   * @param {RegExp|function(String,Stats):Boolean=} options.filter\n   * @param {String=} [options.timeType='birthtime']\n   * @param {Number=} [options.expire=Infinity] - milliseconds\n   * @param {Number=} [options.interval=300000] - milliseconds\n   * @param {Boolean=} [options.autoStart=true]\n   * @param {Boolean=} [options.unsafe=false]\n   * @param {Boolean=} [options.removeEmptyDirs=false]\n   */\n  constructor({\n                folder,\n                unsafe = false,\n                timeType = 'birthtime',\n                filter = /.*/,\n                expire = Infinity,\n                interval = 5 * 60 * 1000,\n                autoStart = true,\n                removeEmptyDirs = false,\n                removeCleanedDirs = true,\n                async = true,\n                dry = true\n              }) {\n    super();\n\n    if (!folder) {\n      throw new Error('folder should be specified');\n    }\n    this.folder = path.resolve(folder);\n    if (!unsafe && this.folder.split(path.sep).length <= 2) {\n      throw new Error(\n        'Cowardly refusing to watch folder ' + folder + ' as it is a root folder. ' +\n        'To override this behaviour, please set \"unsafe\" to be true'\n      );\n    }\n\n    this.timeType = timeType;\n    if (!~validTimeTypes.indexOf(this.timeType)) {\n      throw new Error('timeType should be one of ' + validTimeTypes.join(', '));\n    }\n\n    this.filter = filter;\n    this.expire = expire;\n\n    this.interval = interval;\n    this.autoStart = autoStart;\n\n    this.removeEmptyDirs = removeEmptyDirs;\n    this.removeCleanedDirs = removeCleanedDirs;\n    this.dry = dry;\n\n    this._interval = null;\n\n    if (this.autoStart) {\n      this.start();\n    }\n\n    this._readdir = readdir;\n    this._unlink = unlink;\n    this._stats = stats;\n    this._rmdir = rmdir;\n    if (async) {\n      this._readdir = readdirAsync;\n      this._unlink = unlinkAsync;\n      this._stats = statsAsync;\n      this._rmdir = rmdirAsync;\n    }\n    this._async = async;\n  }\n\n  /**\n   * @return {Promise<ExpireEntry>}\n   */\n  async list() {\n    const entry = new ExpireEntry({\n      async: this._async,\n      path: this.folder,\n      parent: null\n    });\n    await entry.populate();\n    return entry;\n  }\n\n  /**\n   * @param {String} path\n   * @param {Stats} stats\n   * @return {boolean}\n   * @private\n   */\n  _shouldDelete(path, stats) {\n    const time = stats[this.timeType];\n    // if regex check match (false)\n    if (this.filter instanceof RegExp && this.filter.test(path) === false) {\n      return false;\n    }\n    // if function check output (falsy)\n    if (typeof this.filter === 'function' && !this.filter(path, stats)) {\n      return false;\n    }\n    // if now - chosen time < expire time\n    if (Date.now() - time.getTime() < this.expire) {\n      return false;\n    }\n    // delete it\n    return true;\n  }\n\n\n  async clean({ dry = this.dry } = {}) {\n    const entry = await this.list();\n    const list = entry.list();\n    const len = list.length;\n    for (let i = 0; i < len; i++) {\n      const e = list[i];\n\n      // remove empty dirs\n      if (this.removeEmptyDirs && e.isDir && !e.hasChildren) {\n        await e.delete({ keepEmptyParent: !this.removeCleanedDirs, dry });\n      }\n\n      // if it's dir, continue\n      if (e.isDir) {\n        continue;\n      }\n\n      // remove file is necessary\n      if (this._shouldDelete(e.path, e.stats)) {\n        await e.delete({ keepEmptyParent: !this.removeCleanedDirs, dry });\n      }\n    }\n    this.emit('clean');\n  }\n\n  /**\n   * @return {boolean}\n   */\n  stop() {\n    if (!this._interval) {\n      return false; // not started\n    }\n    clearInterval(this._interval);\n    this._interval = null;\n    return true;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  start() {\n    if (this._interval) {\n      return false; // already started\n    }\n    this._interval = setInterval(async () => {\n      try {\n        await this.clean();\n      } catch (e) {\n        this.emit('error', e);\n      }\n    }, this.interval);\n    return true;\n  }\n}\n\n/**\n *\n * @type {{access_time: string, modify_time: string, creation_time: string, birth_time: string}}\n */\nExpireFS.TimeType = {\n  access_time: 'atime',\n  modify_time: 'mtime',\n  creation_time: 'ctime',\n  birth_time: 'birthtime'\n};\n\nmodule.exports = ExpireFS;\n"]}