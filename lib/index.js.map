{"version":3,"sources":["../src/index.js"],"names":["fs","require","path","EventEmitter","readdirAsync","dirname","Promise","res","rej","readdir","e","l","unlinkAsync","filename","unlink","statsAsync","stat","s","rmdirAsync","rmdir","validTimeTypes","ExpireFS","constructor","folder","unsafe","timeType","filter","expire","Infinity","interval","recursive","autoStart","removeEmptyDirs","removeCleanedDirs","Error","resolve","split","sep","length","indexOf","join","_interval","start","_shouldDelete","stats","time","RegExp","test","Date","now","getTime","_clean","dir","list","all","map","item","isDirectory","data","then","x","deleted","file","clean","emit","stop","clearInterval","setInterval","module","exports"],"mappings":"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","file":"index.js","sourcesContent":["const fs = require('fs');\nconst path = require('path');\nconst EventEmitter = require('events');\n\nconst readdirAsync = dirname => new Promise((res, rej) => fs.readdir(dirname, (e, l) => e ? rej(e) : res(l)));\nconst unlinkAsync = filename => new Promise((res, rej) => fs.unlink(filename, e => e ? rej(e) : res()));\nconst statsAsync = filename => new Promise((res, rej) => fs.stat(filename, (e, s) => e ? rej(e) : res(s)));\nconst rmdirAsync = filename => new Promise((res, rej) => fs.rmdir(filename, e => e ? rej(e) : res()));\n\nconst validTimeTypes = ['atime', 'mtime', 'ctime', 'birthtime'];\n\nclass ExpireFS extends EventEmitter {\n\n  /**\n   * @param options\n   * @param {String} options.folder\n   * @param {RegExp|function(String,Stats):Boolean=} options.filter\n   * @param {String=} [options.timeType='birthtime']\n   * @param {Number=} [options.expire=Infinity] - milliseconds\n   * @param {Number=} [options.interval=300000] - milliseconds\n   * @param {Boolean=} [options.recursive=true]\n   * @param {Boolean=} [options.autoStart=true]\n   * @param {Boolean=} [options.unsafe=false]\n   * @param {Boolean=} [options.removeEmptyDirs=false]\n   */\n  constructor({\n                folder,\n                unsafe = false,\n                timeType = 'birthtime',\n                filter = /.*/,\n                expire = Infinity,\n                interval = 5 * 60 * 1000,\n                recursive = true,\n                autoStart = true,\n                removeEmptyDirs = false,\n                removeCleanedDirs = true\n              }) {\n    super();\n\n    if (!folder) {\n      throw new Error('folder should be specified');\n    }\n    this.folder = path.resolve(folder);\n    if (!unsafe && this.folder.split(path.sep).length <= 2) {\n      throw new Error(\n        'Cowardly refusing to watch folder ' + folder + ' as it is a root folder. ' +\n        'To override this behaviour, please set \"unsafe\" to be true'\n      );\n    }\n\n    this.timeType = timeType;\n    if (!~validTimeTypes.indexOf(this.timeType)) {\n      throw new Error('timeType should be one of ' + validTimeTypes.join(', '));\n    }\n\n    this.filter = filter;\n    this.expire = expire;\n\n    this.interval = interval;\n    this.recursive = recursive;\n    this.autoStart = autoStart;\n\n    this.removeEmptyDirs = removeEmptyDirs;\n    this.removeCleanedDirs = removeCleanedDirs;\n\n    this._interval = null;\n\n    if (this.autoStart) {\n      this.start();\n    }\n  }\n\n  /**\n   * @param {String} path\n   * @param {Stats} stats\n   * @return {boolean}\n   * @private\n   */\n  _shouldDelete(path, stats) {\n    const time = stats[this.timeType];\n    // if regex check match (false)\n    if (this.filter instanceof RegExp && this.filter.test(path) === false) {\n      return false;\n    }\n    // if function check output (falsy)\n    if (typeof this.filter === 'function' && !this.filter(path, stats)) {\n      return false;\n    }\n    // if now - chosen time < expire time\n    if (Date.now() - time.getTime() < this.expire) {\n      return false;\n    }\n    // delete it\n    return true;\n  }\n\n  /**\n   * @typedef {Object} ExpireFSFolderFile\n   * @property {String} path\n   * @property {Boolean} deleted\n   * @property {Boolean} file\n   */\n\n  /**\n   * @typedef {Object} ExpireFSFolderChain\n   * @property {String} path\n   * @property {Boolean} folder\n   * @property {Array.<ExpireFSFolderFile|ExpireFSFolderChain>}} list\n   */\n\n  /**\n   * @param {String} dir\n   * @return {PromiseLike<ExpireFSFolderChain[]> | Promise<ExpireFSFolderChain[]>}\n   * @private\n   */\n  async _clean(dir) {\n\n    const list = await readdirAsync(dir);\n\n    return await Promise.all(list\n      .map(item => path.join(dir, item))\n      .map(async path => {\n        const stats = await statsAsync(path);\n\n        if (this.recursive && stats.isDirectory() && path !== '.' && path !== '..') {\n          const data = await this._clean(path).then(x => ({ path, list: x, folder: true })); // recursive on next dir\n\n          // if dir is empty\n          if ((await readdirAsync(path)).length === 0) {\n\n            // and if we want to delete empty dirs\n            if (this.removeEmptyDirs) {\n              // delete dir\n              await rmdirAsync(path);\n            }\n            // and if we want to delete only dirs that have been cleaned up\n            else if (this.removeCleanedDirs && data.list.length > 0) {\n              // delete dir\n              await rmdirAsync(path);\n            }\n\n          }\n          return data;\n        }\n\n        if (!stats.isDirectory() && this._shouldDelete(path, stats) === true) {\n          return await unlinkAsync(path).then(x => ({ path, deleted: true, file: true })); // delete file\n        }\n\n        return { path, deleted: false }\n      })\n    );\n  }\n\n  /**\n   * @return {PromiseLike<ExpireFSFolderChain[]> | Promise<ExpireFSFolderChain[]>}\n   */\n  async clean() {\n    const data = await this._clean(this.folder);\n    this.emit('clean', data);\n    return data;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  stop() {\n    if (!this._interval) {\n      return false; // not started\n    }\n    clearInterval(this._interval);\n    this._interval = null;\n    return true;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  start() {\n    if (this._interval) {\n      return false; // already started\n    }\n    this._interval = setInterval(async () => {\n      try {\n        await this.clean();\n      } catch (e) {\n        this.emit('error', e);\n      }\n    }, this.interval);\n    return true;\n  }\n}\n\nmodule.exports = ExpireFS;\n"]}